<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ClickHouse优化（译） -- 主键索引</title>
      <link href="2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/"/>
      <url>2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes">原文</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="ClickHouse-稀疏主键索引的最佳实践"><a href="#ClickHouse-稀疏主键索引的最佳实践" class="headerlink" title="ClickHouse 稀疏主键索引的最佳实践"></a>ClickHouse 稀疏主键索引的最佳实践</h2><p>在本文中，我们将深入研究 ClickHouse 索引。我们将详细说明以下问题：</p><ul><li><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#an-index-design-for-massive-data-scales">ClickHouse 中的索引与传统的关系型数据库索引有何不同</a></li><li><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#a-table-with-a-primary-key">ClickHouse是 如何构建和使用表的稀疏主键索引的</a></li><li><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple">在 ClickHouse 中建立索引的一些最佳案例是什么</a></li></ul><a id="more"></a><p>您可以选择在自己的机器上自行执行本文中给出的所有 ClickHouse SQL 语句和查询。有关 ClickHouse 的安装和入门说明，请参阅<a href="https://clickhouse.com/docs/en/quick-start">快速入门</a>。</p><blockquote><p>本文重点介绍 ClickHouse 稀疏主键索引。</p><p>对于 ClickHouse<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#table_engine-mergetree-data_skipping-indexes">跳数索引</a>，请参阅此<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">教程</a>。</p></blockquote><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>通过本次教程，我们将使用一个匿名的Web 流量数据集作为示例。</p><ul><li>我们将使用样本数据集中 887 万行（事件）的子数据集。</li><li>未压缩的数据大小大约为 700 MB，并包含887 万个事件。当存储在 ClickHouse 中时，它会被压缩到 200 MB。</li><li>在我们的子数据集中，每行包含三列：网络用户（<code>UserID</code>）在特定时间（<code>EventTime</code>）点击了一条URL（<code>URL</code>）</li></ul><p>通过这三列，我们已经可以制定一些典型的 Web 分析查询，例如：</p><ul><li>指定用户的点击次数排名前10的网址是哪些？</li><li>指定URL 的前10 位活跃用户是哪些？</li><li>用户点击指定URL 的最通常的时间（例如一周中的哪几天）是什么时候？</li></ul><h2 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h2><p>本文档给出的所有运行数据，均基于在配备 Apple M1 Pro 芯片和 16GB RAM 的 MacBook Pro 上本地运行的ClickHouse 22.2.1。</p><h2 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h2><p>为了展现如何在不使用主键的情况下，对我们的数据集执行查询。我们通过执行以下 SQL DDL 语句来创建一个表（使用 MergeTree 表引擎）：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey<span class="token punctuation">(</span>    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> tuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来使用以下 SQL 插入语句将hits数据集的子数据插入到表中。通过<a href="https://clickhouse.com/docs/en/sql-reference/table-functions/url/">URL 表函数</a>与<a href="https://clickhouse.com/blog/whats-new-in-clickhouse-22-1/#schema-inference">结构推断</a>结合使用，以加载在 clickhouse.com 远程托管的完整数据集的子集：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_NoPrimaryKey <span class="token keyword">SELECT</span>   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span><span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">Ok.0 rows in set. Elapsed: 145.993 sec. Processed 8.87 million rows, 18.40 GB (60.78 thousand rows/s., 126.06 MB/s.)</code></pre><p>ClickHouse 客户端的输出结果表明，上面的语句向表中成功写入了 887 万行。</p><p>最后，为了简化本文后面的讨论，并使图表和结果可重现，我们使用 FINAL 关键字[<a href="https://clickhouse.com/docs/en/sql-reference/statements/optimize">optimize</a>] 表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey FINAL<span class="token punctuation">;</span></code></pre><blockquote><p>通常，不需要也不建议在将数据加载到表后立即对其进行optimize 。但这对于这个例子为什么有必要则是显而易见的。</p></blockquote><p>现在执行我们的第一个web分析查询。以下是计算 ID 为 749927693 的互联网用户的点击次数前 10 的网址：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">as</span> Count<span class="token keyword">FROM</span> hits_NoPrimaryKey<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>结果如下：</p><pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐│ http://auto.ru/chatay-barana.. │   170 ││ http://auto.ru/chatay-id=371...│    52 ││ http://public_search           │    45 ││ http://kovrik-medvedevushku-...│    36 ││ http://forumal                 │    33 ││ http://korablitz.ru/L_1OFFER...│    14 ││ http://auto.ru/chatay-id=371...│    14 ││ http://auto.ru/chatay-john-D...│    13 ││ http://auto.ru/chatay-john-D...│    10 ││ http://wot/html?page/23600_m...│     9 │└────────────────────────────────┴───────┘10 rows in set. Elapsed: 0.022 sec.Processed 8.87 million rows,70.45 MB (398.53 million rows/s., 3.17 GB/s.)</code></pre><p>ClickHouse 客户端的输出结果表明， ClickHouse 执行了全表扫描！我们表的 887 万行中的每一行都流式传输到了ClickHouse。这是行不通的。</p><p>为了使这种查询更有效并且更快，我们需要使用具有适当主键的表。这将允许 ClickHouse 自动（基于主键的列）创建稀疏主键索引，然后可以使用该索引明显加快示例查询的执行速度。</p><hr><h1 id="ClickHouse-索引设计"><a href="#ClickHouse-索引设计" class="headerlink" title="ClickHouse 索引设计"></a>ClickHouse 索引设计</h1><h2 id="海量数据规模下的索引设计"><a href="#海量数据规模下的索引设计" class="headerlink" title="海量数据规模下的索引设计"></a>海量数据规模下的索引设计</h2><p>在传统的关系型数据库中，表的每一行都包含一个主键索引。对于我们的数据集，这将导致主键索引: 通常是<a href="https://en.wikipedia.org/wiki/B%2B_tree">B(+)-Tree</a>数据结构，包含 887 万条。</p><p>这样的索引可以快速定位指定行，从而提高查询和定点更新的效率。在 B(+)-Tree 数据结构中查找索引的平均时间复杂度为O(log2 n)。对于 887 万行的表，这意味着只需要23 次搜索就能定位任何索引项。</p><p>这种能力是有代价的：在向表添加新行和向索引中添加项时（有时还会重新平衡 B-Tree），会产生额外的磁盘和内存开销，以及更高的插入成本。</p><p>考虑到与 B-Tree 索引相关的挑战，ClickHouse 中的表引擎采用了不同的方法。ClickHouse <a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/">MergeTree 引擎系列</a>经过设计和优化，可处理大量数据。</p><p>这些表旨在每秒接收数百万行插入并且存储非常大（100 PB+）的数据量。</p><p>数据被快速的<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">逐块</a>写入表，并在后台应用规则合并各块。</p><p>在 ClickHouse 中，每个数据块都有自己的主键索引。当数据块被合并时，合并部分的主键索引也被合并。</p><p>在 ClickHouse 设计的数据规模非常大的情况下，最重要的是要非常高效地使用磁盘和内存。因此，数据块的主键索引不是对每一行都进行索引，而是在每组行数据（称为“粒度”）中有一个索引项（称为“mark”）。</p><p>这种稀疏索引是能实现的，因为 ClickHouse 将数据块的行存储在按主键列排序的磁盘上。</p><p>稀疏索引不是直接定位单行（如基于 B-Tree 的索引），而是通过它快速（通过对索引项的二分搜索）识别可能与查询匹配的行组。</p><p>然后将定位的潜在匹配行（粒度）组并行的流式传输到 ClickHouse 引擎中以找到匹配项。</p><p>这种索引设计允许索引很小（它可以而且必须完全满足主内存），同时仍然显着加快查询执行时间：特别是对于数据分析用例中典型的范围查询。</p><p>下面详细说明 ClickHouse是如何构建和使用稀疏索引的。稍后在本文中，我们将讨论一些如何选择、删除和排序用于构建索引的表列（主键列）的最佳实践。</p><h2 id="具有主键的表"><a href="#具有主键的表" class="headerlink" title="具有主键的表"></a>具有主键的表</h2><p>创建一个具有复合主键的表，其中包含键列 UserID 和 URL：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_UserID_URL<span class="token punctuation">(</span>    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><blockquote><p>DDL语句详情</p><p>为了简化本文后面的探索，并使图表和结果可重现，DDL 声明为</p><ul><li><p>通过<strong>ORDER BY</strong>子句为表指定组合排序键</p></li><li><p>通过以下设置显式控制主键索引将具有的索引项：</p><ul><li>index_granularity：显式设置为其默认值 8192。这意味着对于每组的 8192 行，主键索引将包含一个索引项，例如，如果表包含 16384 行，那么索引将有两个索引项。</li><li>index_granularity_bytes：设置为 0 以禁用<code>自适应索引粒度</code>。自适应索引粒度意味着 ClickHouse 自动为一组 n 行数据创建一个索引项<ul><li>如果 n 小于 8192，但该 n 行的组合行数据的大小大于或等于 10 MB（index_granularity_bytes 的默认值）或</li><li>如果 n 行的组合行数据大小小于 10 MB，但 n 为 8192。</li></ul></li></ul></li></ul></blockquote><p>通过上面 DDL 语句中的主键索引声明，将基于两个指定列创建主键索引。</p><p>接下来写入数据：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_UserID_URL <span class="token keyword">SELECT</span>   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span><span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre><p>响应如下所示：</p><pre class=" language-response"><code class="language-response">0 rows in set. Elapsed: 149.432 sec. Processed 8.87 million rows, 18.40 GB (59.38 thousand rows/s., 123.16 MB/s.)</code></pre><p>然后optimize表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_UserID_URL FINAL<span class="token punctuation">;</span></code></pre><p>我们可以使用以下查询来获取有关我们表的元数据：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    part_type<span class="token punctuation">,</span>    path<span class="token punctuation">,</span>    formatReadableQuantity<span class="token punctuation">(</span><span class="token keyword">rows</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">rows</span><span class="token punctuation">,</span>    formatReadableSize<span class="token punctuation">(</span>data_uncompressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_uncompressed_bytes<span class="token punctuation">,</span>    formatReadableSize<span class="token punctuation">(</span>data_compressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_compressed_bytes<span class="token punctuation">,</span>    formatReadableSize<span class="token punctuation">(</span>primary_key_bytes_in_memory<span class="token punctuation">)</span> <span class="token keyword">AS</span> primary_key_bytes_in_memory<span class="token punctuation">,</span>    marks<span class="token punctuation">,</span>    formatReadableSize<span class="token punctuation">(</span>bytes_on_disk<span class="token punctuation">)</span> <span class="token keyword">AS</span> bytes_on_disk<span class="token keyword">FROM</span> system<span class="token punctuation">.</span>parts<span class="token keyword">WHERE</span> <span class="token punctuation">(</span><span class="token keyword">table</span> <span class="token operator">=</span> <span class="token string">'hits_UserID_URL'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>FORMAT Vertical<span class="token punctuation">;</span></code></pre><p>结果如下：</p><pre class=" language-response"><code class="language-response">part_type:                   Widepath:                        ./store/d9f/d9f36a1a-d2e6-46d4-8fb5-ffe9ad0d5aed/all_1_9_2/rows:                        8.87 milliondata_uncompressed_bytes:     733.28 MiBdata_compressed_bytes:       206.94 MiBprimary_key_bytes_in_memory: 96.93 KiBmarks:                       1083bytes_on_disk:               207.07 MiB1 rows in set. Elapsed: 0.003 sec.</code></pre><p>ClickHouse 客户端的输出表明：</p><ul><li>表数据以<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">宽格式</a>存储在磁盘上的特定目录中，这意味着该目录中的每个表列将有一个数据文件（和一个标记文件）。</li><li>该表有 887 万行。</li><li>所有行的未压缩数据大小合计为 733.28 MB。</li><li>所有行的压缩磁盘数据大小合计为 206.94 MB。</li><li>该表有一个包含 1083 项（称为“mark”）的主键索引，索引的大小为 96.93 KB。</li><li>表的数据和标记文件以及主键索引文件总共占用了 207.07 MB 磁盘空间。</li></ul><h2 id="数据按主键列顺序存储在磁盘上"><a href="#数据按主键列顺序存储在磁盘上" class="headerlink" title="数据按主键列顺序存储在磁盘上"></a>数据按主键列顺序存储在磁盘上</h2><p>我们在上面创建的表包含有</p><ul><li><p>组合<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">主键</a> (UserID, URL)</p></li><li><p>组合<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#choosing-a-primary-key-that-differs-from-the-sorting-key">排序键</a> (UserID, URL, EventTime)</p></li></ul><blockquote><ul><li><p>如果我们只指定排序键，那么主键将被隐式定义为排序键。</p></li><li><p>为了提高内存效率，我们明确的指定了一个主键，它只包含我们查询需要过滤的列。因为基于主键的索引会被完全加载到主存中。</p></li><li><p>为了使文章的图表中保持一致性，并为了最大限度地提高压缩率，我们定义了一个单独的排序键，其中包括我们表的所有列（如果在一列中相似的数据彼此接近，例如通过排序，那么数据将被更好地压缩）。</p></li><li><p>如果两者都指定，则主键必须为排序键的前缀。</p></li></ul></blockquote><p>插入的行按主键列（以及排序键中的附加 EventTime 列）按字典顺序（升序）存储在磁盘上。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><blockquote><p>ClickHouse 允许插入具有相同主键列值的多行。在这种情况下（参见下图中的第 1 行和第 2 行），最终顺序由指定的排序键决定，因此由EventTime列的值决定。</p></blockquote><p>ClickHouse 是一个<a href="https://clickhouse.com/docs/en/introduction/distinctive-features/#true-column-oriented-dbms">面向列的数据库管理系统</a>。如下图所示</p><ul><li>对于磁盘来说，表的每个列都有一个数据文件（*.bin），其中该列的所有值都以<a href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>格式存储。</li><li>887 万行按主键列（和附加的排序键列）按字典升序存储在磁盘上，即在这种情况下<ul><li>首先由UserID排序，</li><li>然后通过URL排序，</li><li>最后是EventTime排序：</li></ul></li></ul><p><img src="../../images/sparse-primary-indexes-01.png" alt="img">UserID.bin、URL.bin 和 EventTime.bin 是磁盘上的数据文件，其中存储了UserID、URL和EventTime列的值。</p><blockquote><p><strong>注意</strong></p><ul><li>由于主键定义了磁盘上行的字典顺序，因此一张表只能有一个主键。</li><li>我们从 0 开始对行进行编号，以便与 ClickHouse 内部行编号结构对齐，该方案也用于记录消息。</li></ul></blockquote><h2 id="数据被分成粒度以进行并行数据处理"><a href="#数据被分成粒度以进行并行数据处理" class="headerlink" title="数据被分成粒度以进行并行数据处理"></a>数据被分成粒度以进行并行数据处理</h2><p>出于数据处理的目的，一个表的列值在逻辑上被划分为粒度组。粒度组是ClickHouse 进行流式数据处理的<strong>最小不可分割</strong>的数据集。这意味着，ClickHouse 不是读取单个行，而是始终读取（以流式和并行方式）整个组（粒度组）的行数据。</p><blockquote><p>列值并不是实际存储在粒度组内部：粒度组只是用于查询处理的列值的 <em>逻辑</em> 组织。</p></blockquote><p>下图说明了我们表的 887 万行（列值）是如何被组织成 1083 个粒度组的，这是由于表的 DDL 语句设置了index_granularity（设置为其默认值 8192）。</p><p><img src="../../images/sparse-primary-indexes-02.png" alt="img"></p><p>第一个（基于磁盘上的物理顺序）8192 行（它们的列值）逻辑上属于粒度 0，然后接下来的 8192 行（它们的列值）属于粒度1，依此类推。</p><blockquote><p><strong>注意</strong></p><ul><li>最后一个粒度组（粒度值1082）“包含”少于 8192 行。</li><li>我们将主键列（UserID、URL）中的一些列值标记为橙色。</li></ul><p>这些橙色标记的列值是每个粒度组中每个主键列的最小值。这里的例外是我们标记最后一个粒度组（上图中的1082粒度组）的最大值。 </p><p> 正如我们将在下面看到的，这些橙色标记的列值将是表的主键索引中的索引项。</p><ul><li>我们从 0 开始对粒度组进行编号，以便与 ClickHouse 内部编号方案保持一致，该方案也用于记录消息。</li></ul></blockquote><h2 id="主键索引每个粒度组有一个索引项"><a href="#主键索引每个粒度组有一个索引项" class="headerlink" title="主键索引每个粒度组有一个索引项"></a>主键索引每个粒度组有一个索引项</h2><p>主键索引是基于上图所示的粒度组创建的。该索引是一个未压缩的扁平化数组文件 (primary.idx)，包含从 0 开始的所谓数字索引标记。</p><p>如下图显示，索引文件存储了每个粒度组的最小主键列值（上图中橙色标记的值）。例如</p><ul><li>第一个索引项（下图中的’mark 0’）存储上图中粒度组0的主键列的最小值，</li><li>第二个索引项（下图中的’mark 1’）存储上图中粒度组1的主键列的最小值，依此类推。</li></ul><p><img src="../../images/sparse-primary-indexes-03a.png" alt="img"></p><p>我们的表总共有 1083 个索引项，887 万行数据和 1083 个粒度组：</p><p><img src="../../images/sparse-primary-indexes-03b.png" alt="img"></p><blockquote><p><strong>注意</strong></p><ul><li>最后一个索引项（上图中的’mark 1082’）是存储上图中粒度组1082的主键列的<strong>最大值</strong>。</li><li>索引项（索引标记）不是基于我们表中的特定行，而是基于粒度组。例如，对于上图中的索引项’mark 0’，我们的表中没有UserID为240.923且URL为”goal://metry=10000467796a411…”的行。相反，表中有一个粒度组 0，其中在该粒度组中，最小 UserID 值为240.923，最小 URL 值为“goal://metry=10000467796a411…”，这两个值来自不同的行。</li><li>主键索引文件被完全加载到主内存中。如果文件大于可用的内存空间，那么ClickHouse 将抛出错误。</li></ul></blockquote><p>主键索引项被称为索引标记，因为每个索引项都标记特定数据范围的最小值。对于示例表：</p><ul><li><p>UserID索引标记：</p><p>主键索引中存储的UserID值按升序排列。<br>上图中的“mark 1”因此代表了在粒度组 1 中的所有行的UserID值，以及在所有后续粒度组中，都保证大于或等于 4.073.710。</p></li></ul><p><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#the-primary-index-is-used-for-selecting-granules">正如我们稍后将看到</a>的，当查询在主键的第一列上进行过滤时，这种全局顺序使 ClickHouse 能够在第一个主键列的索引标记上<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">使用二分查找算法</a>。</p><ul><li><p>URL 索引标记：<br>主键列UserID和URL的基数非常相似，这意味着第一列之后的所有主键列的索引标记通常只代表每个粒度组的数据范围。<br>例如，上图中的URL列的’mark 0’表示粒度组0中所有行的URL值都保证大于等于goal://metry=10000467796a411 …。但是，对于粒度组1中所有行的URL值则不能给出同样的保证，因为UserID列的“mark 1”与“mark 0”具有不同的 UserID 值。</p><p>稍后我们将更详细地讨论这对查询执行性能的影响。</p></li></ul><h2 id="主键索引用于选择粒度组"><a href="#主键索引用于选择粒度组" class="headerlink" title="主键索引用于选择粒度组"></a>主键索引用于选择粒度组</h2><p>我们现在可以在主键索引的支持下执行以下查询。</p><p>下面计算UserID 为 749927693 点击次数前十的 url。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_UserID_URL<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐│ http://auto.ru/chatay-barana.. │   170 ││ http://auto.ru/chatay-id=371...│    52 ││ http://public_search           │    45 ││ http://kovrik-medvedevushku-...│    36 ││ http://forumal                 │    33 ││ http://korablitz.ru/L_1OFFER...│    14 ││ http://auto.ru/chatay-id=371...│    14 ││ http://auto.ru/chatay-john-D...│    13 ││ http://auto.ru/chatay-john-D...│    10 ││ http://wot/html?page/23600_m...│     9 │└────────────────────────────────┴───────┘10 rows in set. Elapsed: 0.005 sec.Processed 8.19 thousand rows,740.18 KB (1.53 million rows/s., 138.59 MB/s.)</code></pre><p>ClickHouse 客户端的输出此时说明，不是进行全表扫描，而是只有 8190行数据流式传输到 ClickHouse。</p><p>如果启用了<a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">跟踪日志</a>，ClickHouse 服务器日志文件将显示 ClickHouse 正在对 1083 个 UserID 索引标记执行<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分查找</a>，从而找到可能包含 UserID 列值为749927693的行的粒度组。这需要平均时间复杂度为O(log2 n)的 19 个步骤：</p><pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in [749927693, 749927693])...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)...Executor): Found (LEFT) boundary mark: 176...Executor): Found (RIGHT) boundary mark: 177...Executor): Found continuous range in 19 steps...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,              1/1083 marks by primary key, 1 marks to read from 1 ranges...Reading ...approx. 8192 rows starting from 1441792</code></pre><p>我们从上面的跟踪日志中可以看出，1083 个现有标记中的一个标记满足查询。</p><blockquote><p>跟踪日志细节</p><p>标记 176 被识别（包含“找到的左边界标记”，排除“找到的右边界标记”），因此来自粒度 176 的所有 8192 行（从第 1.441.792 行开始 - 我们将在稍后看到）流式传输到 ClickHouse 中，以查找 UserID 列值为749927693的实际行。</p></blockquote><p>我们还可以通过在示例查询中使用<a href="https://clickhouse.com/docs/en/sql-reference/statements/explain/">EXPLAIN 子句</a>来重现这一点：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> indexes <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_UserID_URL<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下所示：</p><pre class=" language-response"><code class="language-response">┌─explain───────────────────────────────────────────────────────────────────────────────┐│ Expression (Projection)                                                               ││   Limit (preliminary LIMIT (without OFFSET))                                          ││     Sorting (Sorting for ORDER BY)                                                    ││       Expression (Before ORDER BY)                                                    ││         Aggregating                                                                   ││           Expression (Before GROUP BY)                                                ││             Filter (WHERE)                                                            ││               SettingQuotaAndLimits (Set limits and quota after reading from storage) ││                 ReadFromMergeTree                                                     ││                 Indexes:                                                              ││                   PrimaryKey                                                          ││                     Keys:                                                             ││                       UserID                                                          ││                     Condition: (UserID in [749927693, 749927693])                     ││                     Parts: 1/1                                                        ││                     Granules: 1/1083                                                  │└───────────────────────────────────────────────────────────────────────────────────────┘16 rows in set. Elapsed: 0.003 sec.</code></pre><p>客户端输出表明1083 个粒度组中的一个被选为可能包含 UserID 列值为 749927693 的行。</p><blockquote><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h5><p>当对作为组合主键的一部分且是第一个主键列进行查询过滤时，ClickHouse 将在主键列的索引标记上运行二分查找算法。</p></blockquote><p>如上所述，ClickHouse 正在使用其稀疏主键索引来快速（通过二分查找）选择可能包含与查询匹配的行的粒度组。</p><p>这是 ClickHouse 执行查询的<strong>第一阶段（粒度组选择）</strong>。</p><p>在<strong>第二阶段（数据读取）</strong>，ClickHouse 定位到选定的粒度组，以便将它们的所有行数据流式传输到 ClickHouse 引擎，从而找到实际匹配查询的行。</p><p>我们接下来将再更详细地讨论第二阶段。</p><h2 id="标记文件用于定位粒度组"><a href="#标记文件用于定位粒度组" class="headerlink" title="标记文件用于定位粒度组"></a>标记文件用于定位粒度组</h2><p>下图展示了我们表的主键索引文件的一部分。</p><p><img src="../../images/sparse-primary-indexes-04.png" alt="img"></p><p>如上所述，通过对索引的 1083 个UserID标记进行二分搜索，识别出标记 176。因此，其对应的粒度组176 可能包含 UserID 列值为 749.927.693 的行。</p><blockquote><p>粒度组选择细节</p><p>上图显示，标记 176 是第一个匹配的索引项，其中粒度组 176 的最小 UserID 值小于 749.927.693，并且下一个标记（标记 177）的粒度组177 的最小 UserID 值大于此值。因此，只有176 标记对应的粒度组可能包含 UserID 列值为 749.927.693 的行。</p></blockquote><p>为了确定（或不确定）粒度组 176 中的某些行包含 UserID 列值为749.927.693  ，属于该粒度组的所有 8192 行都需要流式传输到 ClickHouse。</p><p>为此，ClickHouse 需要知道粒度组 176 的物理位置。</p><p>在 ClickHouse 中，我们表的所有粒度组的物理位置都存储在标记文件中。与数据文件类似，每个列都有一个标记文件。</p><p>下图展示了三个标记文件 UserID.mrk、URL.mrk 和 EventTime.mrk，它们存储了表的 UserID、URL 和 EventTime 列的粒度组的物理位置。</p><p><img src="../../images/sparse-primary-indexes-05.png" alt="img"></p><p>我们已经讨论了主键索引为什么是一个扁平的未压缩数组文件 (primary.idx)，其中包含从 0 开始编号的索引标记。</p><p>同样，标记文件也是一个扁平未压缩的数组文件 (*.mrk)，其中包含从 0 开始编号的标记。</p><p>一旦 ClickHouse 识别并选择了可能包含查询匹配行的粒度组的索引标记，就可以在标记文件中执行查找数组位置，以获得粒度组的实际物理位置。</p><p>特定列的每个标记文件项都以偏移量的形式存储两个位置：</p><ul><li>第一个偏移量（上图中的“block_offset”）用于在<a href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>列数据文件中定位<a href="https://clickhouse.com/docs/en/development/architecture/#block">块</a>，包含所选粒度组的压缩版本。该压缩块可能包含一些压缩粒度组。定位的压缩文件块在读取时被解压到主内存中。</li><li>标记文件的第二个偏移量（上图中的“granule_offset”）提供了未压缩块数据中颗粒的位置。</li></ul><p>然后将被定位的未压缩粒度的所有 8192 行流式传输到 ClickHouse 以进行进一步处理。</p><blockquote><p><strong>为什么用标记文件</strong></p><p>为什么主索引不直接包含索引标记对应的粒度的物理位置？</p><p>因为在 ClickHouse 的非常大的数据规模下，十分重要的是磁盘和内存高效使用。</p><p>主索引文件需要加载到主内存。</p><p>对于我们的示例查询，ClickHouse 使用了主索引并选择了一个可能包含与我们的查询匹配的行的单个粒度。只有对于那个粒度，ClickHouse 才需要物理位置，以便流式传输相应的行以进行进一步处理。</p><p>此外，仅 UserID 和 URL 列需要此偏移信息。</p><p>查询中未使用的列不需要偏移信息，例如 EventTime。</p><p>对于我们的示例查询，Clickhouse 只需要 UserID 数据文件 (UserID.bin) 中粒度 176 的两个物理位置偏移量和 URL 数据文件 (URL.data) 中粒度 176 的两个物理位置偏移量。</p><p>标记文件的存在，间接地避免了在主索引中直接存储所有三列的所有 1083 个粒度的物理位置的条目：从而避免在主内存中存在不必要的（可能未使用的）数据。</p></blockquote><p>下图和下面的文本说明了我们的示例是如何查询 ClickHouse 在 UserID.bin 数据文件中定位粒度 176的。</p><p><img src="../../images/sparse-primary-indexes-06.png" alt="img"></p><p>我们在本文前面讨论过 ClickHouse选择了主索引标记 176，因此粒度 176 可能包含我们查询的匹配行。</p><p>ClickHouse 现在使用从索引中选择的标记编号 (176) 在 UserID.mrk 标记文件中进行数组的位置查找，以获得用于定位颗粒 176 的两个偏移量。</p><p>如图所示，第一个偏移量是在 UserID.bin 数据文件中定位压缩文件块，该文件包含粒度 176 的压缩版本。</p><p>一旦定位的文件块被解压到主内存中，标记文件的第二个偏移量可用于在未压缩数据中定位粒度176。</p><p>ClickHouse 需要从 UserID.bin 数据文件和 URL.bin 数据文件中定位（并从其中流式传输所有值）粒度 176 以执行我们的示例查询（UserID 为749.927. 693的互联网用户的前 10 个点击次数最多的 url )。</p><p>上图展示了 ClickHouse 如何定位 UserID.bin 数据文件的粒度。</p><p>此外，ClickHouse 对 URL.bin 数据文件的粒度 176 执行相同的操作。将两个各自的粒度对齐，并流式传输到 ClickHouse 引擎中进行进一步处理，即对 UserID 为 749.927.693 的所有行的每个组的 URL 值进行聚合和计数，最后按降序输出最大的 10 个 URL 组。</p><h1 id="使用多个主键索引"><a href="#使用多个主键索引" class="headerlink" title="使用多个主键索引"></a>使用多个主键索引</h1><h2 id="辅助键是否有效"><a href="#辅助键是否有效" class="headerlink" title="辅助键是否有效"></a>辅助键是否有效</h2><p>当查询对复合主键的一部分并且是第一个键列进行过滤时，<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">ClickHouse 将在键列的索引标记上执行二分搜索算法</a>。</p><p>但是，当查询对复合主键的一部分但不是第一个键列进行过滤时会发生什么？</p><blockquote><p><strong>注意</strong></p><p>我们讨论一个查询保证不是在第一个键列上过滤，而是在辅助键列上过滤的场景。</p><p>当查询同时对第一个键列和第一个键列之后的任何键列进行过滤时，ClickHouse 将对第一个键列的索引标记执行二分搜索。</p></blockquote><p>我们使用一个查询来计算最常点击 URL”http ://public_search”的前 10 个用户：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_UserID_URL<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐│ 2459550954 │  3741 ││ 1084649151 │  2484 ││  723361875 │   729 ││ 3087145896 │   695 ││ 2754931092 │   672 ││ 1509037307 │   582 ││ 3085460200 │   573 ││ 2454360090 │   556 ││ 3884990840 │   539 ││  765730816 │   536 │└────────────┴───────┘10 rows in set. Elapsed: 0.086 sec.Processed 8.81 million rows,799.69 MB (102.11 million rows/s., 9.27 GB/s.)</code></pre><p>客户端的输出表明 ClickHouse 几乎执行了全表扫描，尽管<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">URL 列作为复合主键的一部分</a>！ClickHouse 从表的 887 万行中读取了 881 万行。</p><p>如果启用了<a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">trace_logging</a>，则 ClickHouse 服务器日志文件显示 了ClickHouse 对 1083 个 URL 索引标记使用了<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索</a>，以识别可能包含 URL 列值为“http: //public_search”的行的那些粒度：</p><pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 1 in ['http://public_search',                                           'http://public_search'])...Executor): Used generic exclusion search over index for part all_1_9_2              with 1537 steps...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,              1076/1083 marks by primary key, 1076 marks to read from 5 ranges...Executor): Reading approx. 8814592 rows with 10 streams</code></pre><p>我们可以在上面的示例跟踪日志中看到，1083 个粒度中的 1076 个（通过标记）被选择为可能包含具有匹配 URL 值的行。</p><p>这导致 881 万行被流式传输到 ClickHouse 引擎（并行使用 10 个流），以识别实际包含 URL 值“http: //public_search”的行。</p><p>然而，<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-fast">正如我们稍后将看到</a>的那样，在选定的 1076 个粒度中只有 39 个粒度实际上包含匹配的行。</p><p>虽然基于复合主键 (UserID, URL) 的主索引对于加快具有特定 UserID 值的行的查询过滤非常有用，但该索引在加快过滤具有特定 URL 值的行的查询方面没有提供重要帮助。</p><p>原因是 URL 列不是第一个键列，因此 ClickHouse 在 URL 列的索引标记上使用通用排除搜索算法（而不是二分搜索），并且<strong>该算法的效率取决于</strong>URL 列和它的前置键列 UserID的 <strong>基数差异</strong>。</p><p>为了说明这一点，我们给出了一些关于通用排除搜索是如何执行的细节。</p><h2 id="通用排除搜索算法"><a href="#通用排除搜索算法" class="headerlink" title="通用排除搜索算法"></a>通用排除搜索算法</h2><p>下面说明了<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L14444">ClickHouse 通用排除搜索算法</a>在前置键列具有低（er）或高（er）基数的情况下，辅助键筛选粒度的工作原理。</p><p>作为这两种情况的示例，我们将假设：</p><ul><li>查询 URL 值 = “W3” 的行。</li><li>我们的 hits 表的抽象版本，其中包含 UserID 和 URL 的简化值。</li><li>索引的相同复合主键 (UserID, URL)。这意味着行首先按 UserID 值排序。然后按 URL 对具有相同 UserID 值的行进行排序。</li><li>粒度大小为 2，即每个粒度包含两行。</li></ul><p>我们在下图中用橙色标记了每个颗粒的最小键列值。</p><p><strong>前置键列的基数较低</strong></p><p>假设 UserID 具有低基数。在这种情况下，相同的 UserID 值很可能分布在多个表行和粒度上。对于具有相同 UserID 的索引标记，索引标记的 URL 值按升序排序（因为表行首先按 UserID 排序，然后按 URL 排序）。这能进行有效过滤，如下所示：</p><p><img src="../../images/sparse-primary-indexes-07.png" alt="img"></p><p>上图中我们的抽象样本数据的粒度选择过程有三种不同的场景：</p><ol><li>由于标记索引0、1和2具有相同的UserID值，因此可以排除（最小）<strong>URL值小于W3并且直接后续索引标记的URL值也小于W3的索引标记0。</strong>请注意，此排除的前提是，确保了粒度 0 和下一个粒度1 完全由 U1的 UserID 值组成，因此 ClickHouse 可以推断粒度 0 中的最大 URL 值也小于 W3， 并排除该颗粒。</li><li>选择其<strong>URL 值小于（或等于）W3 并且其直接后续索引标记的 URL 值大于（或等于）W3</strong>的索引标记 1，因为这意味着粒度1 可能包含具有 URL值为W3 的行。</li><li><strong>可以排除URL 值大于 W3</strong>的索引标记 2 和 3 ，因为主键索引的索引标记存储每个粒度的最小键列值，因此粒度 2 和 3 不可能包含 URL 值为 W3的行。</li></ol><p><strong>前置键列的基数的较高</strong></p><p>当 UserID 具有高基数时，相同的 UserID 值不太可能分布在多个表行和粒度上。这意味着索引标记的 URL 值不是单调递增的：</p><p><img src="../../images/sparse-primary-indexes-08.png" alt="img"></p><p>正如我们在上图中看到的，所有显示的 URL 值小于 W3 的标记都被选中，用于将其关联的粒度行都流式传输到 ClickHouse 引擎。</p><p>这是因为虽然图中的所有索引标记都属于上述场景 1，但它们不满足上述排除的前提条件，<em>即两个直接随后的索引标记都具有与当前标记相同的 UserID 值</em>，因此不能被排除.</p><p>例如，考虑索引标记 0 ，其<strong>URL 值小于 W3 并且直接后续索引标记的 URL 值也存在小于 W3</strong>。这<em>不能</em>排除，因为两个紧随其后的索引标记 1 和 2<em>没有</em>与当前标记 0 相同的 UserID 值。</p><p>请注意，要求两个后续索引标记具有相同的 UserID 值。这确保了当前和下一个标记的粒度完全由 U1的 UserID 值组成。如果只有下一个标记具有相同的 UserID，则下一个标记的 URL 值可能源自具有不同 UserID 的表行 - 当您查看上图时确实是这种情况，即 W2 源自 U2，而不是UserID 为U1的行。</p><p>这最终会阻止 ClickHouse 对粒度 0 中的最大 URL 值做出推断。相反，它必须假设粒度 0 可能包含 URL 值为 W3 的行，并被迫选择标记 0。</p><p>同理，标记 1、2 和 3 也是如此。</p><blockquote><p><strong>结论</strong></p><p>当查询对作为复合键的一部分但不是第一个键的列进行过滤，并且前置键列具有较低基数时，ClickHouse 使用<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索算法而不是</a><a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索算法</a>。</p></blockquote><p>在我们的示例数据集中，两个键列（UserID、URL）具有相似的高基数，并且如上所述，当 URL 列的前一个键列具有较高或相似的基数时，通用排除搜索算法并不是十分有效.</p><h2 id="注意跳数索引"><a href="#注意跳数索引" class="headerlink" title="注意跳数索引"></a>注意跳数索引</h2><p>由于 UserID 和 URL 值具有同样高的基数，在<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">使用复合主键 (UserID, URL)</a>的表上的URL列上创建<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">二级跳数索引</a>，并不会<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>有太大的帮助。</p><p>例如，以下两个语句在我们表的 URL 列上创建并填充了一个<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">minmax跳数索引：</a></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> url_skipping_index URL <span class="token keyword">TYPE</span> minmax GRANULARITY <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL MATERIALIZE <span class="token keyword">INDEX</span> url_skipping_index<span class="token punctuation">;</span></code></pre><p>ClickHouse 现在创建了一个附加索引，用于存储 - 每组 4 个连续<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">粒度</a>（注意上面ALTER TABLE语句中的GRANULARITY 4子句） - 的最小和最大 URL 值：</p><p><img src="../../images/sparse-primary-indexes-13a.png" alt="img"></p><p>第一个索引项（上图中的“mark 0”）存储<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">表的前 4 个粒度的行</a>的最小和最大 URL 值。</p><p>第二个索引项（’mark 1’）存储表的后续 4 个粒度的行的最小和最大 URL 值，依此类推。</p><p>（ClickHouse 还为跳数索引创建了一个特殊的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>，用于<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">定位</a>与索引标记关联的粒度组。）</p><p>由于 UserID 和 URL 的基数同样高，所以当我们对 URL执行<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">查询过滤</a>时，这个二级跳数索引无法帮助排除被选中的粒度。</p><p>查询正在查找的特定 URL 值（如 “http: //public_search”）很可能介于索引为每组粒度存储的最小值和最大值之间，导致 ClickHouse 被迫选择粒度组（因为它们可能包含与查询匹配的行）。</p><h2 id="需要使用多个主键索引"><a href="#需要使用多个主键索引" class="headerlink" title="需要使用多个主键索引"></a>需要使用多个主键索引</h2><p>因此，如果我们想要显着加快过滤具有特定 URL 的行的示例查询，那么我们需要使用针对该查询优化的主键索引。</p><p>此外，如果我们希望保持过滤具有特定 UserID 的行的示例查询的良好性能，那么我们需要使用多个主键索引。</p><p>以下是实现这一目标的方法。</p><h2 id="用于创建附加主键索引的选项"><a href="#用于创建附加主键索引的选项" class="headerlink" title="用于创建附加主键索引的选项"></a>用于创建附加主键索引的选项</h2><p>如果我们想显着加快我们的两个示例查询 - 一个过滤具有特定 UserID 的行和一个过滤具有特定 URL 的行 - 那么我们需要通过使用这三个选项之一来使用多个主索引：</p><ul><li>使用不同的主键创建<strong>第二个表。</strong></li><li>在我们现有的表上创建一个<strong>物化视图。</strong></li><li>向我们现有的表添加<strong>投影。</strong></li></ul><p>所有的三个选项都会有效地将我们的样本数据复制到一个附加表中，以便重新组织表的主键索引和行排序顺序。</p><p>但是，这三个选项的不同之处在于附加表对于用户查询和插入语句处理的方便程度。</p><p>当创建了具有不同主键的<strong>第二个表</strong>后，必须将查询显式发送到最适合查询的表中，并且必须将新数据显式插入两个表中以保持表同步：</p><p><img src="../../images/sparse-primary-indexes-09a.png" alt="img"></p><p>使用<strong>物化视图</strong>会隐式创建附加表，并且两个表之间的数据会自动保持同步：</p><p><img src="../../images/sparse-primary-indexes-09b.png" alt="img"></p><p><strong>投影</strong>是最方便的选项，因为除了自动保持隐式创建（和隐藏）附加表与同步数据更改之外，ClickHouse 将自动选择最有效的表版本进行查询：</p><p><img src="../../images/sparse-primary-indexes-09c.png" alt="img"></p><p>在下文中，我们将通过实例来更详细地讨论创建和使用多个主索引的这三个选项。</p><h2 id="选项-1：辅助表"><a href="#选项-1：辅助表" class="headerlink" title="选项 1：辅助表"></a>选项 1：辅助表</h2><p>创建一个新的附加表，在主键中切换了键列的顺序（与原始表相比）：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_URL_UserID<span class="token punctuation">(</span>    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>将<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>中的所有的 887 万行数据插入到附加表中：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_URL_UserID<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre><p>响应如下所示：</p><pre class=" language-response"><code class="language-response">Ok.0 rows in set. Elapsed: 2.898 sec. Processed 8.87 million rows, 838.84 MB (3.06 million rows/s., 289.46 MB/s.)</code></pre><p>最后优化表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_URL_UserID FINAL<span class="token punctuation">;</span></code></pre><p>因为我们切换了主键中列的顺序，插入的行现在以不同的字典顺序存储在磁盘上（与我们的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>相比），因此该表的 1083 个粒度包含与之前不同的值：</p><p><img src="../../images/sparse-primary-indexes-10.png" alt="img"></p><p>这是生成的主键：</p><p><img src="../../images/sparse-primary-indexes-11.png" alt="img"></p><p>现在可以使用它来显着加快我们对 URL 列的示例查询过滤，以计算最常点击的 URL”http: //public_search”的前 10 个用户：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_URL_UserID<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐│ 2459550954 │  3741 ││ 1084649151 │  2484 ││  723361875 │   729 ││ 3087145896 │   695 ││ 2754931092 │   672 ││ 1509037307 │   582 ││ 3085460200 │   573 ││ 2454360090 │   556 ││ 3884990840 │   539 ││  765730816 │   536 │└────────────┴───────┘10 rows in set. Elapsed: 0.017 sec.Processed 319.49 thousand rows,11.38 MB (18.41 million rows/s., 655.75 MB/s.)</code></pre><p>现在， ClickHouse<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#filtering-on-key-columns-after-the-first">没有进行全表扫描</a>，而是更有效地执行了该查询。</p><p>当使用<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>的主索引时，其中 UserID 是第一个，URL 是第二个键列，ClickHouse 对索引标记使用<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-algorithm">通用排除搜索</a>来执行该查询。并且由于 UserID 和URL具有同样高的基数，使得该查询并不高效。</p><p>将 URL 作为主索引中的第一列，ClickHouse 现在对索引标记运行<a href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索</a>。ClickHouse 服务器日志文件中的相应跟踪日志也验证了这一点：</p><pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',                                           'http://public_search'])...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)...Executor): Found (LEFT) boundary mark: 644...Executor): Found (RIGHT) boundary mark: 683...Executor): Found continuous range in 19 steps...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,              39/1083 marks by primary key, 39 marks to read from 1 ranges...Executor): Reading approx. 319488 rows with 2 streams</code></pre><p>ClickHouse 仅选择了 39 个索引标记，而不是使用通用排除搜索时的 1076 个。</p><p>请注意，附加表经过优化，可加快我们对 URL 的示例查询过滤的执行速度。</p><p>与使用<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>时该查询的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-slow">性能不佳</a>同理，我们对 UserID 的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">示例查询过滤</a>在新的附加表中不会有效地执行，因为 UserID 现在是该表主键索引中的第二个键列，因此 ClickHouse 将使用粒度选择的通用排除搜索，对于相似高基数的 UserID 和 URL列<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不是很有效</a>。以下为详细信息。</p><blockquote><p>对 UserID 的查询过滤现在性能很差</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_URL_UserID<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下</p><pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐│ http://auto.ru/chatay-barana.. │   170 ││ http://auto.ru/chatay-id=371...│    52 ││ http://public_search           │    45 ││ http://kovrik-medvedevushku-...│    36 ││ http://forumal                 │    33 ││ http://korablitz.ru/L_1OFFER...│    14 ││ http://auto.ru/chatay-id=371...│    14 ││ http://auto.ru/chatay-john-D...│    13 ││ http://auto.ru/chatay-john-D...│    10 ││ http://wot/html?page/23600_m...│     9 │└────────────────────────────────┴───────┘10 rows in set. Elapsed: 0.024 sec.Processed 8.02 million rows,73.04 MB (340.26 million rows/s., 3.10 GB/s.)</code></pre><p>服务器日志</p><pre class=" language-log"><code class="language-log">...Executor): Key condition: (column 1 in [749927693, 749927693])...Executor): Used generic exclusion search over index for part all_1_9_2              with 1453 steps...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,              980/1083 marks by primary key, 980 marks to read from 23 ranges...Executor): Reading approx. 8028160 rows with 10 streams</code></pre></blockquote><p>我们现在有两张表。分别针对 UserID 的查询过滤和对 URL 的查询过滤进行了优化加速：</p><p><img src="../../images/sparse-primary-indexes-12a.png" alt="img"></p><h2 id="选项-2：物化视图"><a href="#选项-2：物化视图" class="headerlink" title="选项 2：物化视图"></a>选项 2：物化视图</h2><p>在我们现有的表上创建一个<a href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">物化视图</a>。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> MATERIALIZED <span class="token keyword">VIEW</span> mv_hits_URL_UserID<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>POPULATE<span class="token keyword">AS</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre><p>响应如下所示：</p><pre class=" language-response"><code class="language-response">Ok.0 rows in set. Elapsed: 2.935 sec. Processed 8.87 million rows, 838.84 MB (3.02 million rows/s., 285.84 MB/s.)</code></pre><blockquote><p>注意</p><ul><li>我们在视图中的主键切换了主键列的顺序（与我们的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表相比）</a></li><li>物化视图由<strong>隐式创建的表</strong>支持，该表的行顺序和主键索引基于给定的主键定义</li><li>隐式创建的表由SHOW TABLES查询列出，名称以.inner 开头</li><li>也可以首先显式地为物化视图创建依赖表，然后视图可以通过TO [db].[table] <a href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">子句</a>定位该表。</li><li>我们使用POPULATE关键字来立即使用887 万行的源表<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>来填充隐式创建表</li><li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐式创建的表中</li><li>实际上，隐式创建的表与<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主索引：</li></ul></blockquote><p><img src="../../images/sparse-primary-indexes-12b-1.png" alt="img"></p><p>ClickHouse 将隐式创建的表的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在 ClickHouse 服务器数据目录的特殊文件夹中：</p><p><img src="../../images/sparse-primary-indexes-12b-2.png" alt="img"></p><p>支持物化视图的隐式创建的表（以及它的主索引）现在可用于显着加快我们对 URL 列的示例查询过滤的执行速度：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> mv_hits_URL_UserID<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐│ 2459550954 │  3741 ││ 1084649151 │  2484 ││  723361875 │   729 ││ 3087145896 │   695 ││ 2754931092 │   672 ││ 1509037307 │   582 ││ 3085460200 │   573 ││ 2454360090 │   556 ││ 3884990840 │   539 ││  765730816 │   536 │└────────────┴───────┘10 rows in set. Elapsed: 0.026 sec.Processed 335.87 thousand rows,13.54 MB (12.91 million rows/s., 520.38 MB/s.)</code></pre><p>因为实际上支持物化视图的隐式创建的表（以及它的主索引）与<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p><p>ClickHouse 服务器日志文件中的相应跟踪日志验证了 ClickHouse 正在对索引标记执行二分搜索：</p><pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',                                           'http://public_search'])...Executor): Running binary search on index range .........Executor): Selected 4/4 parts by partition key, 4 parts by primary key,              41/1083 marks by primary key, 41 marks to read from 4 ranges...Executor): Reading approx. 335872 rows with 4 streams</code></pre><h2 id="选项-3：投影"><a href="#选项-3：投影" class="headerlink" title="选项 3：投影"></a>选项 3：<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#option-3-projections">投影</a></h2><p>在我们现有的表上创建一个投影：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL    <span class="token keyword">ADD</span> PROJECTION prj_url_userid    <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> <span class="token operator">*</span>        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>并实现投影：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL    MATERIALIZE PROJECTION prj_url_userid<span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意</strong></p><ul><li>投影创建一个<strong>隐藏表</strong>，其行顺序和主键索引基于投影给定的ORDER BY子句</li><li>SHOW TABLES查询不能列出隐藏的投影表</li><li>我们使用MATERIALIZE关键字，以便立即使用源表<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>中的所有 887 万行填充隐藏表</li><li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐藏表中</li><li>查询始终（在语法上）以源表 hits_UserID_URL 为目标，但如果隐藏表的行顺序和主索引允许更有效的查询执行，则将使用该隐藏表代替</li><li>实际上，隐式创建的隐藏表与<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主键索引：</li></ul></blockquote><p><img src="../../images/sparse-primary-indexes-12c-1.png" alt="img"></p><p>ClickHouse 将隐藏表的<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在源表数据文件、标记文件和主索引文件旁边的特殊文件夹中（在下面的截图中标记为橙色）：</p><p><img src="../../images/sparse-primary-indexes-12c-2.png" alt="img"></p><p>由投影创建的隐藏表（以及它的主键索引）现在可以（隐式地）用于显着加快我们在 URL 列上执行示例查询过滤的速度。请注意，查询在语法上以投影的源表为目标。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count<span class="token keyword">FROM</span> hits_UserID_URL<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>响应如下：</p><pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐│ 2459550954 │  3741 ││ 1084649151 │  2484 ││  723361875 │   729 ││ 3087145896 │   695 ││ 2754931092 │   672 ││ 1509037307 │   582 ││ 3085460200 │   573 ││ 2454360090 │   556 ││ 3884990840 │   539 ││  765730816 │   536 │└────────────┴───────┘10 rows in set. Elapsed: 0.029 sec.Processed 319.49 thousand rows, 11.38 MB (11.05 million rows/s., 393.58 MB/s.)</code></pre><p>由于投影创建的隐藏表（以及它的主索引）实际上与<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p><p>ClickHouse 服务器日志文件中的相应跟踪日志证实了ClickHouse 正在对索引标记执行二分搜索：</p><pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',                                           'http://public_search'])...Executor): Running binary search on index range for part prj_url_userid (1083 marks)...Executor): ......Executor): Choose complete Normal projection prj_url_userid...Executor): projection required columns: URL, UserID...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,              39/1083 marks by primary key, 39 marks to read from 1 ranges...Executor): Reading approx. 319488 rows with 2 streams</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">具有复合主键 (UserID, URL)的表</a>的主键索引对于加快<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">UserID 的查询过滤</a>非常有用。但是，尽管 URL 列是复合主键的一部分，但该索引并没有为加快<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url"> URL 的查询过滤</a>提供重要帮助。</p><p>反之亦然：<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#secondary-table">具有复合主键 (URL, UserID) 的表</a>的主键索引能加快<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>，但<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">对 UserID的查询过滤</a>没有提供太多帮助。</p><p>由于主键列 UserID 和 URL 具有相似的高基数，对第二个键列进行过滤的查询<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不会从索引中的第二个键列中获得太多帮助</a>。</p><p><a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes">因此，从主索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主索引</a>是有意义的。</p><p>但是，如果复合主键中的键列在基数上有很大差异，则<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-fast">查询</a>按基数升序排列主键列是有益的。</p><p>键列之间的基数差异越大，这些列在键中的顺序就越重要。我们将在下一节中证明这一点。</p><p>因此，从主键索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主键索引是有意义的。</p><p>但是，如果复合主键中的键列在基数上有很大差异，则按基数升序排列的主键列对查询是有帮助的。</p><p>键列之间的基数差异越大，这些列在键中的顺序就越重要。 我们将在下一节中说明这一点。</p>]]></content>
      
      
      <categories>
          
          <category> ClickHouse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka三节点集群搭建</title>
      <link href="2022/01/10/Kafka%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>2022/01/10/Kafka%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一-整体步骤"><a href="#一-整体步骤" class="headerlink" title="一 整体步骤"></a>一 整体步骤</h2><ul><li>hosts配置</li><li>安装配置Zookeeper</li><li>Kafka集群搭建</li></ul><a id="more"></a><h2 id="二-配置Hosts"><a href="#二-配置Hosts" class="headerlink" title="二 配置Hosts"></a>二 配置Hosts</h2><ul><li><p>修改hosts文件</p><pre class=" language-shell"><code class="language-shell">sudo vi /etc/hosts# 配置如下127.0.0.1   localhost192.168.0.100 master192.168.0.101 slave1192.168.0.102 slave2</code></pre></li></ul><h2 id="三-安装配置Zookeeper"><a href="#三-安装配置Zookeeper" class="headerlink" title="三 安装配置Zookeeper"></a>三 安装配置Zookeeper</h2><ul><li><p>下载解压</p><pre class=" language-shell"><code class="language-shell"># 使用wget或本地下载后传到服务器cd /home/sudo mkdir zookeepercd /home/zookeepersudo wget https://dlcdn.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gzsudo tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz</code></pre></li><li><p>配置环境变量</p><pre class=" language-shell"><code class="language-shell"># 修改三台主机# sudo vi /etc/profile# 添加环境变量export ZOOKEEPER_HOME=/home/zookeeper/apache-zookeeper-3.5.9-binexport PATH=$ZOOKEEPER_HOME/bin:$PATHsource /etc/profile</code></pre></li></ul><ul><li><p>创建目录</p><pre class=" language-shell"><code class="language-shell">cd apache-zookeeper-3.5.9-binsudo mkdir datasudo mkdir logs</code></pre></li></ul><ul><li><p>修改配置</p><pre class=" language-shell"><code class="language-shell">cd confsudo cp zoo_sample.cfg zoo.cfgsudo vi zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/home/zookeeper/apache-zookeeper-3.5.9-bin/datadataLogDir=/home/zookeeper/apache-zookeeper-3.5.9-bin/logsclientPort=2181# 如果为当前主机，则修改为0.0.0.0server.1=master:2287:3387server.2=slave1:2287:3387server.3=slave2:2287:3387</code></pre></li><li><p>创建<code>myid</code>文件</p><blockquote><p>在各服务器节点(<code>master</code>、<code>slave1</code>、<code>slave2</code>)的 <code>dataDir</code> 目录下创建名为 <code>myid</code> 的文件，在文件第一行写上对应的 Server id</p></blockquote><pre class=" language-shell"><code class="language-shell">master:echo "1" > myidslave1:echo "2" > myidslave2:echo "3" > myid</code></pre></li><li><p>启动测试</p><blockquote><p>启动顺序决定leadert,follower</p></blockquote><pre class=" language-shell"><code class="language-shell"># 分别在三台主机上cd /home/zookeeper/apache-zookeeper-3.5.9-bin/bin/zkServer.sh start# 集群验证# 查看状态(需全部节点启动)zkServer.sh status</code></pre></li><li><p>基本命令</p><pre class=" language-shell"><code class="language-shell"># 停止zkServer.sh stop</code></pre></li></ul><h2 id="四-KafKa-集群搭建"><a href="#四-KafKa-集群搭建" class="headerlink" title="四 KafKa 集群搭建"></a>四 KafKa 集群搭建</h2><ul><li><p>下载解压</p><blockquote><p>注意选择版本时，选择<code>Binary downloads</code>,不要选择<code>Source download</code>！！！否则启动时会提示<code>Could not find or load main class kafka.Kafka</code>，此时需要编译后才可以使用 。</p></blockquote><pre class=" language-shell"><code class="language-shell">cd /homemkdir Kafkacd Kafkamkdir datasudo wget https://archive.apache.org/dist/kafka/3.0.0/kafka_2.12-3.0.0.tgztar -xzf kafka_2.12-3.0.0.tgz</code></pre></li><li><p>修改配置</p><pre class=" language-shell"><code class="language-shell">cd kafka_2.12-3.0.0/configvi server.properties# 节点1# 群中每个节点的唯一标识broker.id=0# 监听地址listeners=PLAINTEXT://master:9092# 数据的存储位置log.dirs=/home/Kafka/data# Zookeeper连接地址zookeeper.connect=master:2181,slave1:2181,slave2:2181# 节点2broker.id=1listeners=PLAINTEXT://slave1:9092log.dirs=/home/Kafka/datazookeeper.connect=master:2181,slave1:2181,slave2:2181# 节点3broker.id=2listeners=PLAINTEXT://slave2:9092log.dirs=/home/Kafka/datazookeeper.connect=master:2181,slave1:2181,slave2:2181</code></pre></li><li><p>启动</p><pre class=" language-shell"><code class="language-shell"># 三节点分别运行启动cd /home/Kafka/kafka_2.12-3.0.0bin/kafka-server-start.sh -daemon config/server.properties </code></pre></li><li><p>测试</p><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --create --bootstrap-server master:9092 --replication-factor 1 --partitions 1 --topic testbin/kafka-topics.sh --list --bootstrap-server master:9092bin/kafka-topics.sh --describe --bootstrap-server master:9092 --topic test</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当Clickhouse Distributed遇到ReplacingMergeTree</title>
      <link href="2021/09/07/%E5%BD%93Clickhouse%20Distributed%E9%81%87%E5%88%B0ReplacingMergeTree/"/>
      <url>2021/09/07/%E5%BD%93Clickhouse%20Distributed%E9%81%87%E5%88%B0ReplacingMergeTree/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>​    由于业务限制，数据库中存在大量重复数据，故采用了ReplacingMergeTree表引擎，但后台始终没有进行数据合并。</p><a id="more"></a><ul><li><p>建表语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">ON</span> CLUSTER xxx<span class="token punctuation">(</span>    user_id String<span class="token punctuation">,</span>    name String<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> ReplacingMergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>user_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">ON</span> CLUSTER xxx <span class="token keyword">as</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">Distributed</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span> <span class="token string">'xxxx'</span><span class="token punctuation">,</span> xxxx<span class="token punctuation">,</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><ul><li><p>查询数据是否有重复</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> xxxx<span class="token punctuation">.</span>xxxx<span class="token number">41905623</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> x <span class="token keyword">FROM</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token punctuation">[</span>oder_key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token number">41705616</span></code></pre></li><li><p>手动执行数据合并，也没有去除重复数据</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> <span class="token operator">~</span> <span class="token keyword">ON</span> CLUSTER <span class="token operator">~</span> FINAL<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> xxxx<span class="token punctuation">.</span>xxxx<span class="token number">41905623</span></code></pre></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>​    分布式表存储数据采用分片存储，如6条数据存3个节点，则每个节点存储2条数据。当发生数据合并时，可能只合并当前节点的数据。最终也在这<a href="https://stackoverflow.com/questions/62616949/deduplication-in-distributed-clickhouse-table%EF%BC%8C%E9%AA%8C%E8%AF%81%E4%BA%86%E8%BF%99%E4%B8%80%E7%8C%9C%E6%83%B3%E3%80%82">https://stackoverflow.com/questions/62616949/deduplication-in-distributed-clickhouse-table，验证了这一猜想。</a></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>​    创建分布式表时，不使用rand()进行随机分布，使用user_id进行分片，使相同user_id的数据在写入时落在相同的节点。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">ON</span> CLUSTER xxx <span class="token keyword">as</span> xxxx<span class="token punctuation">.</span>xxxx <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">Distributed</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span> <span class="token string">'xxxx'</span><span class="token punctuation">,</span> xxxx<span class="token punctuation">,</span> user_id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ClickHouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReplacingMergeTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Python3 urllib3 urllib3.exceptions.maxretryerror httpsconnectionpool(host=‘xxxxx‘, port=443)</title>
      <link href="2021/06/21/%E8%A7%A3%E5%86%B3Python3%20urllib3%20urllib3.exceptions.maxretryerror%20httpsconnectionpool(host=%E2%80%98xxxxx%E2%80%98,%20port=443)/"/>
      <url>2021/06/21/%E8%A7%A3%E5%86%B3Python3%20urllib3%20urllib3.exceptions.maxretryerror%20httpsconnectionpool(host=%E2%80%98xxxxx%E2%80%98,%20port=443)/</url>
      
        <content type="html"><![CDATA[<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><p>在使用代理进行请求时，代理只通过<code>HTTP</code>请求，此时请求进行<code>HTTPS</code>验证时验证失败。</p><a id="more"></a><h3 id="两种解决方案"><a href="#两种解决方案" class="headerlink" title="两种解决方案"></a>两种解决方案</h3><ol><li>在<code>1.25</code>版本之前，请求时不会进行HTTPS验证。故可降低urllib3版本。</li></ol><pre class=" language-shell"><code class="language-shell">   1.25 (2019-04-22)   Require and validate certificates by default when using HTTPS (Pull #1507)</code></pre><pre class=" language-shell"><code class="language-shell">pip install -U "urllib3<1.25"</code></pre><ol start="2"><li><p>修改本地代理，将HTTPS覆盖为HTTP请求</p><blockquote><p>Windows 10下打开设置 -&gt; 网络和Internet -&gt; 代理，找到代理的IP和端口</p></blockquote><pre class=" language-python"><code class="language-python">proxies <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:1080'</span><span class="token punctuation">,</span>    <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:1080'</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>res <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstall打包ssl验证错误</title>
      <link href="2021/05/28/Pyinstall%E6%89%93%E5%8C%85ssl%E9%AA%8C%E8%AF%81%E9%94%99%E8%AF%AF/"/>
      <url>2021/05/28/Pyinstall%E6%89%93%E5%8C%85ssl%E9%AA%8C%E8%AF%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>使用Google api，程序能正常运行，但使用PyInstaller打包后出现ssl验证错误</p><blockquote><p>Error: Exception in ‘grpc._cython.cygrpc.ssl_roots_override_callback’ ignored</p><p>assertion failed: pem_root_certs != nullptr</p></blockquote><a id="more"></a><ul><li><p>解决办法</p><p>找到Python安装路径下的\Lib\site-packages\grpc_cython_credentials\roots.pem,</p><p>并拷贝到打包后的exe文件目录下。</p></li></ul><ul><li><p>参考链接</p><blockquote><p><a href="https://github.com/grpc/grpc/issues/9223#issuecomment-412054216">https://github.com/grpc/grpc/issues/9223#issuecomment-412054216</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyInstaller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装三节点Hadoop集群</title>
      <link href="2021/03/22/CentOS7%E5%AE%89%E8%A3%85%E4%B8%89%E8%8A%82%E7%82%B9Hadoop%E9%9B%86%E7%BE%A4/"/>
      <url>2021/03/22/CentOS7%E5%AE%89%E8%A3%85%E4%B8%89%E8%8A%82%E7%82%B9Hadoop%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="一-服务器配置"><a href="#一-服务器配置" class="headerlink" title="一 服务器配置"></a>一 服务器配置</h4><ul><li><p>关闭防火墙</p><pre class=" language-shell"><code class="language-shell"># 查看状态firewall-cmd --state# 停止防火墙systemctl stop firewalld.service# 禁止开机自启动systemctl disable firewalld.service</code></pre></li><li><p>关闭selinux</p><pre class=" language-shell"><code class="language-shell">vi /etc/sysconfig/selinuxSELINUX=disabled</code></pre><a id="more"></a></li></ul><h4 id="二-网络配置"><a href="#二-网络配置" class="headerlink" title="二 网络配置"></a>二 网络配置</h4><ul><li><p>找到待配置网卡</p><pre class=" language-shell"><code class="language-shell">cd /etc/sysconfig/network-scripts/ls# 这里选择ifcfg-enp3s0vi ifcfg-enp3s0</code></pre></li><li><p>修改下列配置</p><pre class=" language-shell"><code class="language-shell">BOOTPROTO=staticONBOOT=yesIPADDR=192.168.0.200GATEWAY=192.168.0.1DNS1=8.8.8.8</code></pre></li><li><p>网络测试</p><pre class=" language-shell"><code class="language-shell">service network restart# 局域网测试ping 192.168.0.229# 外网测试ping www.baidu.com</code></pre></li></ul><h4 id="三-安装Java"><a href="#三-安装Java" class="headerlink" title="三 安装Java"></a>三 安装Java</h4><ul><li><p>创建安装目录</p><pre class=" language-shell"><code class="language-shell">cd /home/whrmkdir javacd java</code></pre></li><li><p>安装wget</p><pre class=" language-shell"><code class="language-shell">yum -y install wget</code></pre></li></ul><ul><li><p>下载解压</p><p>使用wget下载或通过官网下载后，使用WinSCP传到 /home/whr/java 目录下</p><pre class=" language-shell"><code class="language-shell">cd /home/whr/javatar -zxvf jdk-8u281-linux-x64.tar.gz</code></pre></li><li><p>设置环境变量</p><pre class=" language-shell"><code class="language-shell">vi /etc/profile# 末尾添加export JAVA_HOME=/home/whr/java/jdk1.8.0_281export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH# 激活环境变量source /etc/profile</code></pre></li><li><p>添加软链接</p><pre class=" language-shell"><code class="language-shell">ln -s /home/whr/java/jdk1.8.0_281/bin/java /usr/bin/java</code></pre></li><li><p>安装完成</p><pre class=" language-shell"><code class="language-shell">java -version</code></pre></li></ul><h4 id="四-配置hosts"><a href="#四-配置hosts" class="headerlink" title="四 配置hosts"></a>四 配置hosts</h4><ul><li><p>节点规划</p><table><thead><tr><th>IP</th><th>NodeType</th><th>Name</th></tr></thead><tbody><tr><td>192.168.0.200</td><td>DataNode</td><td>slave1</td></tr><tr><td>192.168.0.201</td><td>DataNode</td><td>slave2</td></tr><tr><td>192.168.0.202</td><td>NameNode / DataNode</td><td>master</td></tr></tbody></table></li><li><p>hosts 配置</p><pre class=" language-shell"><code class="language-shell">vi /etc/hosts# 配置如下127.0.0.1   localhost192.168.0.200 slave1192.168.0.201 slave2192.168.0.202 master</code></pre></li></ul><h4 id="五-配置SSH（主节点）"><a href="#五-配置SSH（主节点）" class="headerlink" title="五 配置SSH（主节点）"></a>五 配置SSH（主节点）</h4><ul><li><p>修改配置文件</p><pre class=" language-shell"><code class="language-shell">vi /etc/ssh/sshd_configAuthorizedKeysFile      .ssh/authorized_keysPubkeyAuthentication yes</code></pre></li><li><p>生成秘钥</p><pre class=" language-shell"><code class="language-shell">ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa</code></pre></li></ul><ul><li><p>分发公钥</p><pre class=" language-shell"><code class="language-shell">ssh-copy-id -i ~/.ssh/id_dsa.pub masterssh-copy-id -i ~/.ssh/id_dsa.pub slave1ssh-copy-id -i ~/.ssh/id_dsa.pub slave2# 验证ssh masterssh slave1ssh slave2</code></pre></li></ul><h4 id="六-安装Hadoop（主节点）"><a href="#六-安装Hadoop（主节点）" class="headerlink" title="六 安装Hadoop（主节点）"></a>六 安装Hadoop（主节点）</h4><ul><li><p>下载</p><pre class=" language-shell"><code class="language-shell">cd /home/whrmkdir hadoopcd hadoopwget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz# 或本地下载使用WinSCP传送</code></pre></li><li><p>安装</p><pre class=" language-shell"><code class="language-shell">tar zxvf hadoop-3.2.1.tar.gz# 创建软链接ln -s /home/whr/hadoop/hadoop-3.2.1  /usr/local/hadoop</code></pre></li><li><p>配置Hadoop环境变量</p><pre class=" language-shell"><code class="language-shell">vi /etc/profile# 末尾添加export HADOOP_HOME=/home/whr/hadoop/hadoop-3.2.1export PATH=$&#123;HADOOP_HOME&#125;/bin:$PATHsource /etc/profile</code></pre></li><li><p>修改配置文件</p><pre class=" language-shell"><code class="language-shell">cd /usr/local/hadoop/etc/hadoop</code></pre><ul><li><p>配置hadoop-env.sh</p><pre class=" language-shell"><code class="language-shell">vi hadoop-env.shexport JAVA_HOME=/home/whr/java/jdk1.8.0_281</code></pre></li><li><p>配置core-site.xml</p><pre class=" language-shell"><code class="language-shell">vi core-site.xml<configuration>    <property>      <name>hadoop.tmp.dir</name>   <value>/home/whr/hadoop/tmp</value>   <description>Abase for other temporary directories.</description>    </property>    <property>      <name>fs.default.name</name>      <value>hdfs://master:9000</value>    </property></configuration></code></pre></li><li><p>配置hdfs-site.xml</p><pre class=" language-shell"><code class="language-shell">vi hdfs-site.xml<configuration>    <property>      <name>dfs.namenode.name.dir</name>      <value>/home/whr/hadoop/dfs/name</value>    </property>    <property>      <name>dfs.datanode.data.dir</name>      <value>/home/whr/hadoop/dfs/data</value>    </property></configuration></code></pre></li><li><p>配置yarn-site.xml</p><pre class=" language-shell"><code class="language-shell">vi yarn-site.xml<configuration>    <property>      <name>yarn.nodemanager.aux-services</name>      <value>mapreduce_shuffle</value>    </property>    <property>      <name>yarn.nodemanager.aux-services.mapreduce_shuffle.class</name>      <value>org.apache.hadoop.mapred.ShuffleHandler</value>    </property>    <property>      <name>yarn.resourcemanager.hostname</name>      <value>master</value>    </property></configuration></code></pre></li><li><p>配置mapred-site.xml</p><pre class=" language-shell"><code class="language-shell">vi mapred-site.xml<configuration>    <property>      <name>mapred.job.tracker</name>      <value>master:49001</value>    </property>    <property>      <name>mapred.local.dir</name>      <value>/home/whr/hadoop/var</value>    </property>    <property>      <name>mapreduce.framework.name</name>      <value>yarn</value>    </property></configuration></code></pre></li><li><p>配置workers</p><pre class=" language-shell"><code class="language-shell">vi workersmasterslave1slave2</code></pre></li><li><p>修改hdfs启动和停止脚本</p><pre class=" language-shell"><code class="language-shell">cd /usr/local/hadoop/sbinvi start-dfs.shvi stop-dfs.sh# 在最前面加如下内容HDFS_DATANODE_USER=rootHADOOP_SECURE_DN_USER=rootHDFS_NAMENODE_USER=rootHDFS_SECONDARYNAMENODE_USER=root</code></pre></li><li><p>修改yarn启动和停止脚本</p><pre class=" language-shell"><code class="language-shell">cd /usr/local/hadoop/sbinvi start-yarn.shvi stop-yarn.sh# 在文件前添加如下内容YARN_RESOURCEMANAGER_USER=rootHADOOP_SECURE_DN_USER=rootYARN_NODEMANAGER_USER=root</code></pre></li></ul></li><li><p>从节点配置Hadoop</p><pre class=" language-shell"><code class="language-shell"># 将配置好的Hadoop复制到从节点scp -r /home/whr/hadoop/hadoop-3.2.1 root@192.168.0.201:/home/whr/hadoop/# 设置软链接ssh slave1ln -s /home/whr/hadoop/hadoop-3.2.1  /usr/local/hadoopexitssh slave2ln -s /home/whr/hadoop/hadoop-3.2.1  /usr/local/hadoopexit</code></pre></li></ul><h4 id="七-启动测试"><a href="#七-启动测试" class="headerlink" title="七 启动测试"></a>七 启动测试</h4><ul><li><p>格式化namenode</p><pre class=" language-shell"><code class="language-shell">hdfs namenode -format# 重新格式化需要删除tmp和dfs文件夹</code></pre></li><li><p>启动hdfs</p><pre class=" language-shell"><code class="language-shell">cd /usr/local/hadoop/sbinbash start-all.sh</code></pre></li><li><p>启动yarn</p><pre class=" language-shell"><code class="language-shell">bash start-all.sh</code></pre></li><li><p>验证</p><pre class=" language-shell"><code class="language-shell">jps4800 NodeManager4002 NameNode4387 SecondaryNameNode4666 ResourceManager13355 Jps4126 DataNode</code></pre></li></ul><h1 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h1><p>  <a href="http://192.168.0.202:9870/">http://192.168.0.202:9870/</a><br>  <a href="http://192.168.0.202:8088/">http://192.168.0.202:8088/</a></p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstaller打包配置文件</title>
      <link href="2021/03/05/Pyinstaller%20%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>2021/03/05/Pyinstaller%20%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p>Pyinstaller 打包配置文件夹</p><a id="more"></a><ol><li><p>生成资源文件目录访问路径</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> sys<span class="token keyword">def</span> <span class="token function">resource_path</span><span class="token punctuation">(</span>relative_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> getattr<span class="token punctuation">(</span>sys<span class="token punctuation">,</span> <span class="token string">'frozen'</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        base_path <span class="token operator">=</span> sys<span class="token punctuation">.</span>_MEIPASS    <span class="token keyword">else</span><span class="token punctuation">:</span>        base_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>base_path<span class="token punctuation">,</span> relative_path<span class="token punctuation">)</span></code></pre></li><li><p>修改需要读取路径的文件或文件夹</p><pre class=" language-python"><code class="language-python">resource_path<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>打包py文件生成.spec文件</p><pre class=" language-powershell"><code class="language-powershell">pyinstaller <span class="token operator">-</span>F QueryGui<span class="token punctuation">.</span>py</code></pre></li><li><p>修改.spec文件中datas项，添加配置文件目录和待生成的文件夹名</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> Analysis<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             pathex<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             binaries<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             datas<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'config'</span><span class="token punctuation">,</span> <span class="token string">'config'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre></li><li><p>删除build和dist文件夹，重新生成打包文件</p><pre><code>pyinstaller -F QueryGui.spec</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium获取请求信息</title>
      <link href="2021/01/26/Selenium%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF/"/>
      <url>2021/01/26/Selenium%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    在获取facebook analytics数据时，抓取到的请求需要携带token，且具有时效性。</p><a id="more"></a><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li>JS逆向分析token生成过程及逻辑（难度较大，尝试无果后放弃）</li><li>使用selenium模拟请求，将过程交给浏览器，只需要获取结果</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriveroption <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>ChromeOptions<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用本地cookie, 运行时需关闭已打开的浏览器</span>option<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>r<span class="token string">'--user-data-dir=C:\...\User Data'</span><span class="token punctuation">)</span>option<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--profile-directory=Default'</span><span class="token punctuation">)</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span>options<span class="token operator">=</span>option<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.facebook.com/analytics/"</span><span class="token punctuation">)</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取selenium执行了那些请求的关键</span>test <span class="token operator">=</span> browser<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"var performance = window.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance || &amp;#123;&amp;#125;; var network = performance.getEntries() || &amp;#123;&amp;#125;; return network;"</span><span class="token punctuation">)</span>access_token <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> item <span class="token keyword">in</span> test<span class="token punctuation">:</span>  <span class="token keyword">if</span> <span class="token string">"access_token"</span> <span class="token keyword">in</span> item<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    access_token <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>access_token<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集及Python实现</title>
      <link href="2021/01/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8APython%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/01/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并查集：在计算机科学中，<strong>并查集</strong>是一种树型的<strong>数据结构</strong>，用于处理一些<strong>不交集</strong>（Disjoint Sets）的合并及查询问题。   —wiki</p></blockquote><a id="more"></a><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​    并查集，顾名思义，包含了<strong>合并</strong>和<strong>查询</strong>操作，用于解决动态连通性问题。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 主体框架</span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 初始化</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true"># 查询根节点</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true"># 合并节点</span>    <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true"># 判断两个节点是否连通</span>    <span class="token keyword">def</span> <span class="token function">is_same_set</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span></code></pre><ul><li><p>初始化</p><p>将所有节点的父节点设为None</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>father_dict <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>    <span class="token comment" spellcheck="true"># 记录集合的数量，一般为返回值</span>    self<span class="token punctuation">.</span>nums_set <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>father_dict<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> None            <span class="token comment" spellcheck="true"># 集合的数量+1</span>            self<span class="token punctuation">.</span>nums_set <span class="token operator">+=</span> <span class="token number">1</span></code></pre></li><li><p>查询</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>    root <span class="token operator">=</span> x    <span class="token keyword">while</span> self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">!=</span> None<span class="token punctuation">:</span>        root <span class="token operator">=</span> self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>root<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 路径压缩</span>    <span class="token keyword">while</span> x <span class="token operator">!=</span> root<span class="token punctuation">:</span>        cur_father <span class="token operator">=</span> self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>x<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> root        x <span class="token operator">=</span> cur_father    <span class="token keyword">return</span> root</code></pre></li><li><p>合并</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    a_root<span class="token punctuation">,</span> b_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 任意指定一个节点为父节点</span>    <span class="token keyword">if</span> a_root <span class="token operator">!=</span> b_root<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>father_dict<span class="token punctuation">[</span>a_root<span class="token punctuation">]</span> <span class="token operator">=</span> b_root        self<span class="token punctuation">.</span>nums_set <span class="token operator">-=</span> <span class="token number">1</span></code></pre></li><li><p>判断是否在同一集合</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_same_set</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>b<span class="token punctuation">)</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas浅析</title>
      <link href="2021/01/07/pandas%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/07/pandas%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h4><p>​    <a id="more"></a></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd</code></pre><ol><li><p>读取csv文件并转为DataFrame</p><pre class=" language-Python"><code class="language-Python">csv_data = pd.read_csv("test_data.csv", encoding = "ISO-8859-1")</code></pre></li></ol><ol start="2"><li><p>字典转为DataFrame</p><pre class=" language-Python"><code class="language-Python">d = &#123;'col1': [1, 2], 'col2': [3, 4]&#125;df = pd.DataFrame(data=d)</code></pre><table><thead><tr><th align="right"></th><th align="right">col1</th><th align="right"><strong>col2</strong></th></tr></thead><tbody><tr><td align="right">0</td><td align="right">1</td><td align="right">3</td></tr><tr><td align="right">1</td><td align="right">2</td><td align="right">4</td></tr></tbody></table></li><li><p>双层列表转为DataFrame</p><pre class=" language-Python"><code class="language-Python">data = [['tom', 10], ['nick', 15], ['juli', 14]] # Create the pandas DataFrame df = pd.DataFrame(data, columns = ['Name', 'Age']) </code></pre><table><thead><tr><th align="right"></th><th align="right">Name</th><th align="right">Age</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">tom</td><td align="right">10</td></tr><tr><td align="right">1</td><td align="right">nick</td><td align="right">15</td></tr><tr><td align="right">2</td><td align="right">juli</td><td align="right">14</td></tr></tbody></table></li><li><p>列表字典转DataFrame</p><pre class=" language-Python"><code class="language-Python">data = [&#123;'a': 1, 'b': 2, 'c':3&#125;,         &#123;'a':10, 'b': 20, 'c': 30&#125;] # Creates DataFrame. df = pd.DataFrame(data) </code></pre><table><thead><tr><th align="right"></th><th align="right">a</th><th align="right">b</th><th align="right">c</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">1</td><td align="right">2</td><td align="right">3</td></tr><tr><td align="right">1</td><td align="right">10</td><td align="right">20</td><td align="right">30</td></tr></tbody></table></li><li><p>指定index</p><pre class=" language-python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'rank1'</span><span class="token punctuation">,</span>                                 <span class="token string">'rank2'</span><span class="token punctuation">,</span>                                 <span class="token string">'rank3'</span><span class="token punctuation">,</span>                                 <span class="token string">'rank4'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li></ol><h4 id="修改DataFrame值"><a href="#修改DataFrame值" class="headerlink" title="修改DataFrame值"></a>修改DataFrame值</h4><ol><li><p>修改一列的值</p><pre class=" language-Python"><code class="language-Python">df["data"] = df["data"].map(lambda x: 0)</code></pre></li><li><p>修改多列的值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> index<span class="token punctuation">,</span> row <span class="token keyword">in</span> df_res<span class="token punctuation">.</span>iterrows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    df_res<span class="token punctuation">.</span>at<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token string">'data1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    df_res<span class="token punctuation">.</span>at<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token string">'data2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span></code></pre></li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li><p>整体转为str</p><pre class=" language-Python"><code class="language-Python">df = df.astype(str)</code></pre></li><li><p>整体转为int</p><pre class=" language-python"><code class="language-python">df <span class="token operator">=</span> df<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>int<span class="token punctuation">)</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器实现日志输出</title>
      <link href="2020/11/20/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"/>
      <url>2020/11/20/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># @Time    : 2020/11/20 11:33</span><span class="token comment" spellcheck="true"># @Author  : Wanghairui</span><span class="token comment" spellcheck="true"># @function:</span><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">import</span> logging<span class="token keyword">def</span> <span class="token function">_create_logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span><span class="token string">'LogError'</span><span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span>    file_handler <span class="token operator">=</span> logging<span class="token punctuation">.</span>FileHandler<span class="token punctuation">(</span>r<span class="token string">'./MJlogs.log'</span><span class="token punctuation">)</span>    log_format <span class="token operator">=</span> <span class="token string">'%(levelname)s %(asctime)s %(message)s'</span>    formatter <span class="token operator">=</span> logging<span class="token punctuation">.</span>Formatter<span class="token punctuation">(</span>log_format<span class="token punctuation">)</span>    file_handler<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>formatter<span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>file_handler<span class="token punctuation">)</span>    <span class="token keyword">return</span> logger<span class="token keyword">def</span> <span class="token function">logged</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">do_logging</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>            logger <span class="token operator">=</span> _create_logger<span class="token punctuation">(</span><span class="token punctuation">)</span>            error_msg <span class="token operator">=</span> <span class="token string">'And error has occurred at /'</span> <span class="token operator">+</span> func<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">'\n'</span>            logger<span class="token punctuation">.</span>exception<span class="token punctuation">(</span>error_msg<span class="token punctuation">)</span>            <span class="token keyword">return</span> e    <span class="token keyword">return</span> do_logging</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python虚拟环境配置</title>
      <link href="2020/11/16/Python%E4%BD%BF%E7%94%A8Virtualenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>2020/11/16/Python%E4%BD%BF%E7%94%A8Virtualenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p>安装 virtualenv</p><pre class=" language-shell"><code class="language-shell">pip install virtualenv</code></pre></li><li><p>切换到项目目录下，创建虚拟环境</p><pre class=" language-shell"><code class="language-shell">Windows: virtualenv -p python venvlinux: sudo virtualenv -p python3 venv</code></pre></li><li><p>激活虚拟环境</p><pre class=" language-shell"><code class="language-shell"># windowscd venv/Scriptsactivate# linuxsource venv/bin/activate</code></pre></li><li><p>生成requirement文件</p><pre class=" language-shell"><code class="language-shell">pip freeze > requirements.txt</code></pre></li><li><p>安装requirements.txt所需的模块</p><pre class=" language-shell"><code class="language-shell">pip install -r requirements.txt</code></pre></li><li><p>退出虚拟环境</p><pre class=" language-shell"><code class="language-shell">deactivate</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python生产者消费者模型</title>
      <link href="2020/11/06/Python%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/11/06/Python%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> queue<span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">ThreadProductorConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 初始化模型</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 大小为15的缓冲池，用于容纳产品</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">productor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 生产者不停的每3秒生产一个产品</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>product<span class="token punctuation">)</span>            cur_time <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y-%m-%d %H:%M:%S'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cur_name <span class="token operator">=</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            <span class="token comment" spellcheck="true"># print是线程不安全的,需要信号量确保没有冲突</span>            self<span class="token punctuation">.</span>screen_lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur_time<span class="token operator">+</span><span class="token string">"  "</span> <span class="token operator">+</span> cur_name <span class="token operator">+</span> <span class="token string">" 生产了一个产品"</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>screen_lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 消费者不停的每2秒消费一个产品</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            cur_time <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y-%m-%d %H:%M:%S'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cur_name <span class="token operator">=</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            self<span class="token punctuation">.</span>screen_lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur_time <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> cur_name <span class="token operator">+</span> <span class="token string">" 消费了一个产品"</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>screen_lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    tpc <span class="token operator">=</span> ThreadProductorConsumer<span class="token punctuation">(</span><span class="token punctuation">)</span>    p <span class="token operator">=</span> <span class="token string">"product"</span>    <span class="token comment" spellcheck="true"># 实例化了3个生产者</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>tpc<span class="token punctuation">.</span>productor<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 实例化了6个消费者</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        v <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>tpc<span class="token punctuation">.</span>consumer<span class="token punctuation">)</span>        v<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript浅析</title>
      <link href="2020/10/27/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/27/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><ul><li><p>Number :</p><ul><li>整数，浮点数，NaN（Not a Number）,Infinity（无限大）</li><li>NaN 与任何值都不相同，包括自己，可通过isNaN()函数判断NaN</li></ul></li></ul><a id="more"></a><ul><li><p><strong>字符串</strong></p><ul><li><p>多行字符串：``</p></li><li><p>模板字符串</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'小明'</span><span class="token punctuation">;</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token template-string"><span class="token string">`你好, $&amp;#123;name&amp;#125;, 你今年$&amp;#123;age&amp;#125;岁了!`</span></span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>字符串操作</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// length获取长度</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 13</span><span class="token comment" spellcheck="true">// 获取指定位置字符</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'H'</span><span class="token comment" spellcheck="true">// toUpperCase() 字符串全转为大写</span><span class="token comment" spellcheck="true">// toLowerCase() 字符串全转为小写</span><span class="token comment" spellcheck="true">// indexOf()搜索指定字符串出现的位置</span>s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回7</span><span class="token comment" spellcheck="true">//substring()返回指定索引区间的子串</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从索引0开始到5（不包括5），返回'hello'</span></code></pre></li><li><p>字符串不可变</p></li></ul></li><li><p>布尔值</p></li><li><p>null和undefined，大多数情况下，使用null而不是undefined</p></li></ul><h2 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h2><ul><li><p>==：比较时会自动转换数据类型</p></li><li><p>===：只比较数据类型一致的数据</p></li></ul><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><ul><li><p>同一数组可以包含不同数据类型</p></li><li><p>数组操作</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//length 获取数组的长度,给length赋值将导致数组长度变化</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span><span class="token comment" spellcheck="true">// indexOf 搜索一个指定的元素的位置</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">//切片 slice 截取数组的部分元素，返回一个新的数组</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span><span class="token keyword">var</span> aCopy <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 复制数组</span><span class="token comment" spellcheck="true">//push() 向数组添加若干元素</span><span class="token comment" spellcheck="true">//pop() 删除最后一个元素</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回Array新的长度: 4</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 'A', 'B']</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pop()返回'B'</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 'A']</span><span class="token comment" spellcheck="true">//unshift() 向数组头部添加若干元素</span><span class="token comment" spellcheck="true">// shift() 删除数组的第一个元素</span><span class="token comment" spellcheck="true">//sort() 对数组进行排序，默认顺序</span><span class="token comment" spellcheck="true">//reverse() 反转数组</span><span class="token comment" spellcheck="true">//splice()从指定的索引开始删除若干元素，然后再从该位置添加若干元素</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Microsoft'</span><span class="token punctuation">,</span> <span class="token string">'Apple'</span><span class="token punctuation">,</span> <span class="token string">'Yahoo'</span><span class="token punctuation">,</span> <span class="token string">'AOL'</span><span class="token punctuation">,</span> <span class="token string">'Excite'</span><span class="token punctuation">,</span> <span class="token string">'Oracle'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从索引2开始删除3个元素,然后再添加两个元素:</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Facebook'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span><span class="token comment" spellcheck="true">// 只删除,不添加:</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['Google', 'Facebook']</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['Microsoft', 'Apple', 'Oracle']</span><span class="token comment" spellcheck="true">// 只添加,不删除:</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Facebook'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回[],因为没有删除任何元素</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span><span class="token comment" spellcheck="true">//concat() 将两个数组连接起来，返回一个新数组</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['A', 'B', 'C', 1, 2, 3, 4]</span><span class="token comment" spellcheck="true">//join() 把当前数组的每个元素都用指定的字符串连接起来，然后返回连接后的字符串</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'A-B-C-1-2-3'</span></code></pre></li></ul><h2 id="四、对象"><a href="#四、对象" class="headerlink" title="四、对象"></a>四、对象</h2><ul><li><p>类似于Python的字典    </p></li><li><p>获取对象属性：对象变量.属性名，person.name</p></li><li><p>判断是否包含某个属性：</p><p>in操作符：继承的属性也算</p><p>hasOwnProperty(): 不包含继承的属性</p></li></ul><h2 id="五、strict模式"><a href="#五、strict模式" class="headerlink" title="五、strict模式"></a>五、strict模式</h2><blockquote><p>如果一个变量没有通过var声明就使用，则该变量就自动被声明为全局变量</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//启用strict</span><span class="token string">'use strict'</span><span class="token punctuation">;</span></code></pre><h2 id="六、map和set"><a href="#六、map和set" class="headerlink" title="六、map和set"></a>六、map和set</h2><ul><li><p>map</p><blockquote><p>代替对象存储键值数据，具有极快的查询速度</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 覆盖掉上面的Adam值</span>m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 88</span></code></pre></li><li><p>set</p><blockquote><p>只存值，且值不会重复</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 重复元素被过滤</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set &amp;#123;1, 2, 3, "3"&amp;#125;</span><span class="token comment" spellcheck="true">// 可以重复添加，但不会有效果</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set &amp;#123;1, 2, 3, 4&amp;#125;</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set &amp;#123;1, 2, 3, 4&amp;#125;</span></code></pre></li></ul><h2 id="七、常用方法"><a href="#七、常用方法" class="headerlink" title="七、常用方法"></a>七、常用方法</h2><ul><li><p>forEach()</p><blockquote><p>ES5.1标准引入,用于遍历可迭代对象</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span>a<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// map,参数分别为值，键和map</span><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> map<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// set,Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">,</span> sameElement<span class="token punctuation">,</span> <span class="token keyword">set</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><ul><li><p>匿名函数：<code>function (x) &#123; ... &#125;</code></p></li><li><p>可以传入多于或少于函数定义的参数的个数</p></li><li><p>关键字arguments：将传入的参数保存为类似于Array</p></li><li><p>rest参数：rest参数写在最后，前面用<code>...</code>标识，用于将多出的参数保存到Array中</p></li><li><p>let关键字：用于声明局部变量，所声明的变量，只在<code>let</code>命令所在的代码块内有效</p></li><li><p>const: <code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域</p></li><li><p>解构赋值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//直接对多个变量同时赋值</span><span class="token keyword">var</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript'</span><span class="token punctuation">,</span> <span class="token string">'ES6'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token punctuation">[</span>y<span class="token punctuation">,</span> z<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'JavaScript'</span><span class="token punctuation">,</span> <span class="token string">'ES6'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript'</span><span class="token punctuation">,</span> <span class="token string">'ES6'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 忽略前两个元素，只对z赋值第三个元素</span></code></pre></li><li><p>闭包：返回值为函数的函数</p></li><li><p>箭头函数：相当于匿名函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> yx <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="九、需要注意的点"><a href="#九、需要注意的点" class="headerlink" title="九、需要注意的点"></a>九、需要注意的点</h2><ul><li>JavaScript引擎在行末自动添加分号</li><li>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现</li><li>返回闭包时，返回函数不要引用任何循环变量，或者后续会发生变化的变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flask Vue跨域配置</title>
      <link href="2020/10/27/%E9%85%8D%E7%BD%AEFlask+Vue%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
      <url>2020/10/27/%E9%85%8D%E7%BD%AEFlask+Vue%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li><h4 id="配置Flask"><a href="#配置Flask" class="headerlink" title="配置Flask"></a>配置Flask</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 安装flask_cors</span>pip install flask_cors<span class="token keyword">from</span> flask_cors <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment" spellcheck="true">#全局配置</span>CORS<span class="token punctuation">(</span>app<span class="token punctuation">,</span> supports_credentials<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><a id="more"></a></li><li><h4 id="配置Vue"><a href="#配置Vue" class="headerlink" title="配置Vue"></a>配置Vue</h4><p>1.找到config目录下的index.js，在proxyTable下添加配置信息:</p><pre class=" language-js"><code class="language-js"><span class="token string">'/api'</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> target<span class="token punctuation">:</span> <span class="token string">'http://localhost:5000/'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//后端接口地址</span> changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">//是否允许跨越</span> pathRewrite<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token string">'^/api'</span><span class="token punctuation">:</span> <span class="token string">'http://localhost:5000/'</span> <span class="token comment" spellcheck="true">//路径重写</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/9403344-10e8372429b51b34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="proxyTable配置.png"></p><p>  2.在axios中，请求地址改为：’api/xxx/xxx’<br><img src="https://upload-images.jianshu.io/upload_images/9403344-aaa1a996feda6586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="url.png"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio.Semaphore控制协程并发量</title>
      <link href="2020/10/14/Python%E4%BD%BF%E7%94%A8asyncio.Semaphore%E6%8E%A7%E5%88%B6%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%87%8F/"/>
      <url>2020/10/14/Python%E4%BD%BF%E7%94%A8asyncio.Semaphore%E6%8E%A7%E5%88%B6%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># @Time    : 2020/10/12 12:03</span><span class="token comment" spellcheck="true"># @Author  : Wanghairui</span><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> time<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 控制并发数 20</span>    sem <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>print_something<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"运行结束"</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span>t<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> t <span class="token keyword">in</span> tasks<span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    elapsed <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>elapsed<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">print_something</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> sem<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>thing<span class="token punctuation">)</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">"A"</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo指令</title>
      <link href="2019/07/27/hexo%E6%8C%87%E4%BB%A4/"/>
      <url>2019/07/27/hexo%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo指令"><a href="#hexo指令" class="headerlink" title="hexo指令"></a>hexo指令</h2><h5 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h5><pre><code>hexo ghexo shttp://localhost:4000/</code></pre><h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5><pre><code>hexo cleanhexo ghexo d</code></pre>]]></content>
      
      
      <categories>
          
          <category> 指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
