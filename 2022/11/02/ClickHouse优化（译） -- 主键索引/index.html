<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>ClickHouse优化（译） -- 主键索引 | Hexo</title>
  <meta name="description" content="原文 介绍ClickHouse 稀疏主键索引的最佳实践在本文中，我们将深入研究 ClickHouse 索引。我们将详细说明以下问题：  ClickHouse 中的索引与传统的关系型数据库索引有何不同 ClickHouse是 如何构建和使用表的稀疏主键索引的 在 ClickHouse 中建立索引的一些最佳案例是什么">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse优化（译） -- 主键索引">
<meta property="og:url" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name">
<meta property="og:description" content="原文 介绍ClickHouse 稀疏主键索引的最佳实践在本文中，我们将深入研究 ClickHouse 索引。我们将详细说明以下问题：  ClickHouse 中的索引与传统的关系型数据库索引有何不同 ClickHouse是 如何构建和使用表的稀疏主键索引的 在 ClickHouse 中建立索引的一些最佳案例是什么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-01.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-02.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-03a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-03b.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-04.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-05.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-06.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-07.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-08.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-13a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-09a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-09b.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-09c.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-10.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-11.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-12a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-12b-1.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-12b-2.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-12c-1.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-12c-2.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-14a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-14b.png">
<meta property="og:image" content="https://onehr7.github.io/images/sparse-primary-indexes-15a.png">
<meta property="og:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-15b.png">
<meta property="article:published_time" content="2022-11-02T14:02:15.000Z">
<meta property="article:modified_time" content="2022-11-04T14:05:18.389Z">
<meta property="article:author" content="Hairui Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/%5Cimages%5Csparse-primary-indexes-01.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/index.html">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 5.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Onehr7" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">mortal</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chengdu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Onehr7" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p></p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ClickHouse/">ClickHouse</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8C%87%E4%BB%A4/">指令</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyInstaller/" rel="tag">PyInstaller</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReplacingMergeTree/" rel="tag">ReplacingMergeTree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pandas/" rel="tag">pandas</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium/" rel="tag">selenium</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl/" rel="tag">ssl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%87%E4%BB%A4/" rel="tag">指令</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/PyInstaller/" style="font-size: 13px;">PyInstaller</a> <a href="/tags/ReplacingMergeTree/" style="font-size: 13px;">ReplacingMergeTree</a> <a href="/tags/Web/" style="font-size: 13px;">Web</a> <a href="/tags/pandas/" style="font-size: 13px;">pandas</a> <a href="/tags/selenium/" style="font-size: 13px;">selenium</a> <a href="/tags/ssl/" style="font-size: 13px;">ssl</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 13px;">协程</a> <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" style="font-size: 13px;">字节码</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13px;">并发</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 13px;">并查集</a> <a href="/tags/%E6%8C%87%E4%BB%A4/" style="font-size: 13px;">指令</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Python/">Python</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/07/Python%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%A4%E5%80%BC%E4%BA%92%E6%8D%A2/" class="title">Python字节码分析两值互换</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-07T15:02:15.000Z" itemprop="datePublished">2022-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/ClickHouse/">ClickHouse</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/04/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E8%B7%B3%E6%95%B0%E7%B4%A2%E5%BC%95/" class="title">ClickHouse优化（译） -- 跳数索引</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-04T14:02:15.000Z" itemprop="datePublished">2022-11-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/ClickHouse/">ClickHouse</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/" class="title">ClickHouse优化（译） -- 主键索引</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-02T14:02:15.000Z" itemprop="datePublished">2022-11-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kafka/">Kafka</a>
              </p>
              <p class="item-title">
                <a href="/2022/01/10/Kafka%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="title">Kafka三节点集群搭建</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-10T11:50:15.000Z" itemprop="datePublished">2022-01-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/ClickHouse/">ClickHouse</a>
              </p>
              <p class="item-title">
                <a href="/2021/09/07/%E5%BD%93Clickhouse%20Distributed%E9%81%87%E5%88%B0ReplacingMergeTree/" class="title">当Clickhouse Distributed遇到ReplacingMergeTree</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-07T14:48:02.000Z" itemprop="datePublished">2021-09-07</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-ClickHouse优化（译） -- 主键索引" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      ClickHouse优化（译） -- 主键索引
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/" class="article-date">
	  <time datetime="2022-11-02T14:02:15.000Z" itemprop="datePublished">2022-11-02</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/ClickHouse/">ClickHouse</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 13.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 52(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes">原文</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="ClickHouse-稀疏主键索引的最佳实践"><a href="#ClickHouse-稀疏主键索引的最佳实践" class="headerlink" title="ClickHouse 稀疏主键索引的最佳实践"></a>ClickHouse 稀疏主键索引的最佳实践</h2><p>在本文中，我们将深入研究 ClickHouse 索引。我们将详细说明以下问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#an-index-design-for-massive-data-scales">ClickHouse 中的索引与传统的关系型数据库索引有何不同</a></li>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#a-table-with-a-primary-key">ClickHouse是 如何构建和使用表的稀疏主键索引的</a></li>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple">在 ClickHouse 中建立索引的一些最佳案例是什么</a></li>
</ul>
<a id="more"></a>

<p>您可以选择在自己的机器上自行执行本文中给出的所有 ClickHouse SQL 语句和查询。有关 ClickHouse 的安装和入门说明，请参阅<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/quick-start">快速入门</a>。</p>
<blockquote>
<p>本文重点介绍 ClickHouse 稀疏主键索引。</p>
<p>对于 ClickHouse<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#table_engine-mergetree-data_skipping-indexes">跳数索引</a>，请参阅此<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">教程</a>。</p>
</blockquote>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>通过本次教程，我们将使用一个匿名的Web 流量数据集作为示例。</p>
<ul>
<li>我们将使用样本数据集中 887 万行（事件）的子数据集。</li>
<li>未压缩的数据大小大约为 700 MB，并包含887 万个事件。当存储在 ClickHouse 中时，它会被压缩到 200 MB。</li>
<li>在我们的子数据集中，每行包含三列：网络用户（<code>UserID</code>）在特定时间（<code>EventTime</code>）点击了一条URL（<code>URL</code>）</li>
</ul>
<p>通过这三列，我们已经可以制定一些典型的 Web 分析查询，例如：</p>
<ul>
<li>指定用户的点击次数排名前10的网址是哪些？</li>
<li>指定URL 的前10 位活跃用户是哪些？</li>
<li>用户点击指定URL 的最通常的时间（例如一周中的哪几天）是什么时候？</li>
</ul>
<h2 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h2><p>本文档给出的所有运行数据，均基于在配备 Apple M1 Pro 芯片和 16GB RAM 的 MacBook Pro 上本地运行的ClickHouse 22.2.1。</p>
<h2 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h2><p>为了展现如何在不使用主键的情况下，对我们的数据集执行查询。我们通过执行以下 SQL DDL 语句来创建一个表（使用 MergeTree 表引擎）：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> tuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>接下来使用以下 SQL 插入语句将hits数据集的子数据插入到表中。通过<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/table-functions/url/">URL 表函数</a>与<a target="_blank" rel="noopener" href="https://clickhouse.com/blog/whats-new-in-clickhouse-22-1/#schema-inference">结构推断</a>结合使用，以加载在 clickhouse.com 远程托管的完整数据集的子集：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_NoPrimaryKey <span class="token keyword">SELECT</span>
   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 145.993 sec. Processed 8.87 million rows, 18.40 GB (60.78 thousand rows/s., 126.06 MB/s.)</code></pre>
<p>ClickHouse 客户端的输出结果表明，上面的语句向表中成功写入了 887 万行。</p>
<p>最后，为了简化本文后面的讨论，并使图表和结果可重现，我们使用 FINAL 关键字[<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/optimize">optimize</a>] 表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey FINAL<span class="token punctuation">;</span></code></pre>
<blockquote>
<p>通常，不需要也不建议在将数据加载到表后立即对其进行optimize 。但这对于这个例子为什么有必要则是显而易见的。</p>
</blockquote>
<p>现在执行我们的第一个web分析查询。以下是计算 ID 为 749927693 的互联网用户的点击次数前 10 的网址：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">as</span> Count
<span class="token keyword">FROM</span> hits_NoPrimaryKey
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>结果如下：</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.022 sec.
Processed 8.87 million rows,
70.45 MB (398.53 million rows/s., 3.17 GB/s.)</code></pre>
<p>ClickHouse 客户端的输出结果表明， ClickHouse 执行了全表扫描！我们表的 887 万行中的每一行都流式传输到了ClickHouse。这是行不通的。</p>
<p>为了使这种查询更有效并且更快，我们需要使用具有适当主键的表。这将允许 ClickHouse 自动（基于主键的列）创建稀疏主键索引，然后可以使用该索引明显加快示例查询的执行速度。</p>
<hr>
<h1 id="ClickHouse-索引设计"><a href="#ClickHouse-索引设计" class="headerlink" title="ClickHouse 索引设计"></a>ClickHouse 索引设计</h1><h2 id="海量数据规模下的索引设计"><a href="#海量数据规模下的索引设计" class="headerlink" title="海量数据规模下的索引设计"></a>海量数据规模下的索引设计</h2><p>在传统的关系型数据库中，表的每一行都包含一个主键索引。对于我们的数据集，这将导致主键索引: 通常是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%2B_tree">B(+)-Tree</a>数据结构，包含 887 万条。</p>
<p>这样的索引可以快速定位指定行，从而提高查询和定点更新的效率。在 B(+)-Tree 数据结构中查找索引的平均时间复杂度为O(log2 n)。对于 887 万行的表，这意味着只需要23 次搜索就能定位任何索引项。</p>
<p>这种能力是有代价的：在向表添加新行和向索引中添加项时（有时还会重新平衡 B-Tree），会产生额外的磁盘和内存开销，以及更高的插入成本。</p>
<p>考虑到与 B-Tree 索引相关的挑战，ClickHouse 中的表引擎采用了不同的方法。ClickHouse <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/">MergeTree 引擎系列</a>经过设计和优化，可处理大量数据。</p>
<p>这些表旨在每秒接收数百万行插入并且存储非常大（100 PB+）的数据量。</p>
<p>数据被快速的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">逐块</a>写入表，并在后台应用规则合并各块。</p>
<p>在 ClickHouse 中，每个数据块都有自己的主键索引。当数据块被合并时，合并部分的主键索引也被合并。</p>
<p>在 ClickHouse 设计的数据规模非常大的情况下，最重要的是要非常高效地使用磁盘和内存。因此，数据块的主键索引不是对每一行都进行索引，而是在每组行数据（称为“粒度”）中有一个索引项（称为“mark”）。</p>
<p>这种稀疏索引是能实现的，因为 ClickHouse 将数据块的行存储在按主键列排序的磁盘上。</p>
<p>稀疏索引不是直接定位单行（如基于 B-Tree 的索引），而是通过它快速（通过对索引项的二分搜索）识别可能与查询匹配的行组。</p>
<p>然后将定位的潜在匹配行（粒度）组并行的流式传输到 ClickHouse 引擎中以找到匹配项。</p>
<p>这种索引设计允许索引很小（它可以而且必须完全满足主内存），同时仍然显着加快查询执行时间：特别是对于数据分析用例中典型的范围查询。</p>
<p>下面详细说明 ClickHouse是如何构建和使用稀疏索引的。稍后在本文中，我们将讨论一些如何选择、删除和排序用于构建索引的表列（主键列）的最佳实践。</p>
<h2 id="具有主键的表"><a href="#具有主键的表" class="headerlink" title="具有主键的表"></a>具有主键的表</h2><p>创建一个具有复合主键的表，其中包含键列 UserID 和 URL：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_UserID_URL
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>DDL语句详情</p>
<p>为了简化本文后面的探索，并使图表和结果可重现，DDL 声明为</p>
<ul>
<li><p>通过<strong>ORDER BY</strong>子句为表指定组合排序键</p>
</li>
<li><p>通过以下设置显式控制主键索引将具有的索引项：</p>
<ul>
<li>index_granularity：显式设置为其默认值 8192。这意味着对于每组的 8192 行，主键索引将包含一个索引项，例如，如果表包含 16384 行，那么索引将有两个索引项。</li>
<li>index_granularity_bytes：设置为 0 以禁用<code>自适应索引粒度</code>。自适应索引粒度意味着 ClickHouse 自动为一组 n 行数据创建一个索引项<ul>
<li>如果 n 小于 8192，但该 n 行的组合行数据的大小大于或等于 10 MB（index_granularity_bytes 的默认值）或</li>
<li>如果 n 行的组合行数据大小小于 10 MB，但 n 为 8192。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>通过上面 DDL 语句中的主键索引声明，将基于两个指定列创建主键索引。</p>
<p>接下来写入数据：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_UserID_URL <span class="token keyword">SELECT</span>
   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">0 rows in set. Elapsed: 149.432 sec. Processed 8.87 million rows, 18.40 GB (59.38 thousand rows/s., 123.16 MB/s.)</code></pre>
<p>然后optimize表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_UserID_URL FINAL<span class="token punctuation">;</span></code></pre>
<p>我们可以使用以下查询来获取有关我们表的元数据：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    part_type<span class="token punctuation">,</span>
    path<span class="token punctuation">,</span>
    formatReadableQuantity<span class="token punctuation">(</span><span class="token keyword">rows</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">rows</span><span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_uncompressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_uncompressed_bytes<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_compressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_compressed_bytes<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>primary_key_bytes_in_memory<span class="token punctuation">)</span> <span class="token keyword">AS</span> primary_key_bytes_in_memory<span class="token punctuation">,</span>
    marks<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>bytes_on_disk<span class="token punctuation">)</span> <span class="token keyword">AS</span> bytes_on_disk
<span class="token keyword">FROM</span> system<span class="token punctuation">.</span>parts
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span><span class="token keyword">table</span> <span class="token operator">=</span> <span class="token string">'hits_UserID_URL'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
FORMAT Vertical<span class="token punctuation">;</span></code></pre>
<p>结果如下：</p>
<pre class=" language-response"><code class="language-response">part_type:                   Wide
path:                        ./store/d9f/d9f36a1a-d2e6-46d4-8fb5-ffe9ad0d5aed/all_1_9_2/
rows:                        8.87 million
data_uncompressed_bytes:     733.28 MiB
data_compressed_bytes:       206.94 MiB
primary_key_bytes_in_memory: 96.93 KiB
marks:                       1083
bytes_on_disk:               207.07 MiB


1 rows in set. Elapsed: 0.003 sec.</code></pre>
<p>ClickHouse 客户端的输出表明：</p>
<ul>
<li>表数据以<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">宽格式</a>存储在磁盘上的特定目录中，这意味着该目录中的每个表列将有一个数据文件（和一个标记文件）。</li>
<li>该表有 887 万行。</li>
<li>所有行的未压缩数据大小合计为 733.28 MB。</li>
<li>所有行的压缩磁盘数据大小合计为 206.94 MB。</li>
<li>该表有一个包含 1083 项（称为“mark”）的主键索引，索引的大小为 96.93 KB。</li>
<li>表的数据和标记文件以及主键索引文件总共占用了 207.07 MB 磁盘空间。</li>
</ul>
<h2 id="数据按主键列顺序存储在磁盘上"><a href="#数据按主键列顺序存储在磁盘上" class="headerlink" title="数据按主键列顺序存储在磁盘上"></a>数据按主键列顺序存储在磁盘上</h2><p>我们在上面创建的表包含有</p>
<ul>
<li><p>组合<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">主键</a> (UserID, URL)</p>
</li>
<li><p>组合<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#choosing-a-primary-key-that-differs-from-the-sorting-key">排序键</a> (UserID, URL, EventTime)</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>如果我们只指定排序键，那么主键将被隐式定义为排序键。</p>
</li>
<li><p>为了提高内存效率，我们明确的指定了一个主键，它只包含我们查询需要过滤的列。因为基于主键的索引会被完全加载到主存中。</p>
</li>
<li><p>为了使文章的图表中保持一致性，并为了最大限度地提高压缩率，我们定义了一个单独的排序键，其中包括我们表的所有列（如果在一列中相似的数据彼此接近，例如通过排序，那么数据将被更好地压缩）。</p>
</li>
<li><p>如果两者都指定，则主键必须为排序键的前缀。</p>
</li>
</ul>
</blockquote>
<p>插入的行按主键列（以及排序键中的附加 EventTime 列）按字典顺序（升序）存储在磁盘上。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><blockquote>
<p>ClickHouse 允许插入具有相同主键列值的多行。在这种情况下（参见下图中的第 1 行和第 2 行），最终顺序由指定的排序键决定，因此由EventTime列的值决定。</p>
</blockquote>
<p>ClickHouse 是一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#true-column-oriented-dbms">面向列的数据库管理系统</a>。如下图所示</p>
<ul>
<li>对于磁盘来说，表的每个列都有一个数据文件（*.bin），其中该列的所有值都以<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>格式存储。</li>
<li>887 万行按主键列（和附加的排序键列）按字典升序存储在磁盘上，即在这种情况下<ul>
<li>首先由UserID排序，</li>
<li>然后通过URL排序，</li>
<li>最后是EventTime排序：</li>
</ul>
</li>
</ul>
<p><img src="%5Cimages%5Csparse-primary-indexes-01.png" alt="img">UserID.bin、URL.bin 和 EventTime.bin 是磁盘上的数据文件，其中存储了UserID、URL和EventTime列的值。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>由于主键定义了磁盘上行的字典顺序，因此一张表只能有一个主键。</li>
<li>我们从 0 开始对行进行编号，以便与 ClickHouse 内部行编号结构对齐，该方案也用于记录消息。</li>
</ul>
</blockquote>
<h2 id="数据被分成粒度以进行并行数据处理"><a href="#数据被分成粒度以进行并行数据处理" class="headerlink" title="数据被分成粒度以进行并行数据处理"></a>数据被分成粒度以进行并行数据处理</h2><p>出于数据处理的目的，一个表的列值在逻辑上被划分为粒度组。粒度组是ClickHouse 进行流式数据处理的<strong>最小不可分割</strong>的数据集。这意味着，ClickHouse 不是读取单个行，而是始终读取（以流式和并行方式）整个组（粒度组）的行数据。</p>
<blockquote>
<p>列值并不是实际存储在粒度组内部：粒度组只是用于查询处理的列值的 <em>逻辑</em> 组织。</p>
</blockquote>
<p>下图说明了我们表的 887 万行（列值）是如何被组织成 1083 个粒度组的，这是由于表的 DDL 语句设置了index_granularity（设置为其默认值 8192）。</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-02.png" alt="img"></p>
<p>第一个（基于磁盘上的物理顺序）8192 行（它们的列值）逻辑上属于粒度 0，然后接下来的 8192 行（它们的列值）属于粒度1，依此类推。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>最后一个粒度组（粒度值1082）“包含”少于 8192 行。</li>
<li>我们将主键列（UserID、URL）中的一些列值标记为橙色。</li>
</ul>
<p>这些橙色标记的列值是每个粒度组中每个主键列的最小值。这里的例外是我们标记最后一个粒度组（上图中的1082粒度组）的最大值。 </p>
<p>正如我们将在下面看到的，这些橙色标记的列值将是表的主键索引中的索引项。</p>
<ul>
<li>我们从 0 开始对粒度组进行编号，以便与 ClickHouse 内部编号方案保持一致，该方案也用于记录消息。</li>
</ul>
</blockquote>
<h2 id="主键索引每个粒度组有一个索引项"><a href="#主键索引每个粒度组有一个索引项" class="headerlink" title="主键索引每个粒度组有一个索引项"></a>主键索引每个粒度组有一个索引项</h2><p>主键索引是基于上图所示的粒度组创建的。该索引是一个未压缩的扁平化数组文件 (primary.idx)，包含从 0 开始的所谓数字索引标记。</p>
<p>如下图显示，索引文件存储了每个粒度组的最小主键列值（上图中橙色标记的值）。例如</p>
<ul>
<li>第一个索引项（下图中的’mark 0’）存储上图中粒度组0的主键列的最小值，</li>
<li>第二个索引项（下图中的’mark 1’）存储上图中粒度组1的主键列的最小值，依此类推。</li>
</ul>
<p><img src="%5Cimages%5Csparse-primary-indexes-03a.png" alt="img"></p>
<p>我们的表总共有 1083 个索引项，887 万行数据和 1083 个粒度组：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-03b.png" alt="img"></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>最后一个索引项（上图中的’mark 1082’）是存储上图中粒度组1082的主键列的<strong>最大值</strong>。</li>
<li>索引项（索引标记）不是基于我们表中的特定行，而是基于粒度组。例如，对于上图中的索引项’mark 0’，我们的表中没有UserID为240.923且URL为”goal://metry=10000467796a411…”的行。相反，表中有一个粒度组 0，其中在该粒度组中，最小 UserID 值为240.923，最小 URL 值为“goal://metry=10000467796a411…”，这两个值来自不同的行。</li>
<li>主键索引文件被完全加载到主内存中。如果文件大于可用的内存空间，那么ClickHouse 将抛出错误。</li>
</ul>
</blockquote>
<p>主键索引项被称为索引标记，因为每个索引项都标记特定数据范围的最小值。对于示例表：</p>
<ul>
<li><p>UserID索引标记：</p>
<p>主键索引中存储的UserID值按升序排列。<br>上图中的“mark 1”因此代表了在粒度组 1 中的所有行的UserID值，以及在所有后续粒度组中，都保证大于或等于 4.073.710。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#the-primary-index-is-used-for-selecting-granules">正如我们稍后将看到</a>的，当查询在主键的第一列上进行过滤时，这种全局顺序使 ClickHouse 能够在第一个主键列的索引标记上<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">使用二分查找算法</a>。</p>
<ul>
<li><p>URL 索引标记：<br>主键列UserID和URL的基数非常相似，这意味着第一列之后的所有主键列的索引标记通常只代表每个粒度组的数据范围。<br>例如，上图中的URL列的’mark 0’表示粒度组0中所有行的URL值都保证大于等于goal://metry=10000467796a411 …。但是，对于粒度组1中所有行的URL值则不能给出同样的保证，因为UserID列的“mark 1”与“mark 0”具有不同的 UserID 值。</p>
<p>稍后我们将更详细地讨论这对查询执行性能的影响。</p>
</li>
</ul>
<h2 id="主键索引用于选择粒度组"><a href="#主键索引用于选择粒度组" class="headerlink" title="主键索引用于选择粒度组"></a>主键索引用于选择粒度组</h2><p>我们现在可以在主键索引的支持下执行以下查询。</p>
<p>下面计算UserID 为 749927693 点击次数前十的 url。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.005 sec.
Processed 8.19 thousand rows,
740.18 KB (1.53 million rows/s., 138.59 MB/s.)</code></pre>
<p>ClickHouse 客户端的输出此时说明，不是进行全表扫描，而是只有 8190行数据流式传输到 ClickHouse。</p>
<p>如果启用了<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">跟踪日志</a>，ClickHouse 服务器日志文件将显示 ClickHouse 正在对 1083 个 UserID 索引标记执行<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分查找</a>，从而找到可能包含 UserID 列值为749927693的行的粒度组。这需要平均时间复杂度为O(log2 n)的 19 个步骤：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in [749927693, 749927693])
...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)
...Executor): Found (LEFT) boundary mark: 176
...Executor): Found (RIGHT) boundary mark: 177
...Executor): Found continuous range in 19 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              1/1083 marks by primary key, 1 marks to read from 1 ranges
...Reading ...approx. 8192 rows starting from 1441792</code></pre>
<p>我们从上面的跟踪日志中可以看出，1083 个现有标记中的一个标记满足查询。</p>
<blockquote>
<p>跟踪日志细节</p>
<p>标记 176 被识别（包含“找到的左边界标记”，排除“找到的右边界标记”），因此来自粒度 176 的所有 8192 行（从第 1.441.792 行开始 - 我们将在稍后看到）流式传输到 ClickHouse 中，以查找 UserID 列值为749927693的实际行。</p>
</blockquote>
<p>我们还可以通过在示例查询中使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/explain/">EXPLAIN 子句</a>来重现这一点：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> indexes <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">┌─explain───────────────────────────────────────────────────────────────────────────────┐
│ Expression (Projection)                                                               │
│   Limit (preliminary LIMIT (without OFFSET))                                          │
│     Sorting (Sorting for ORDER BY)                                                    │
│       Expression (Before ORDER BY)                                                    │
│         Aggregating                                                                   │
│           Expression (Before GROUP BY)                                                │
│             Filter (WHERE)                                                            │
│               SettingQuotaAndLimits (Set limits and quota after reading from storage) │
│                 ReadFromMergeTree                                                     │
│                 Indexes:                                                              │
│                   PrimaryKey                                                          │
│                     Keys:                                                             │
│                       UserID                                                          │
│                     Condition: (UserID in [749927693, 749927693])                     │
│                     Parts: 1/1                                                        │
│                     Granules: 1/1083                                                  │
└───────────────────────────────────────────────────────────────────────────────────────┘

16 rows in set. Elapsed: 0.003 sec.</code></pre>
<p>客户端输出表明1083 个粒度组中的一个被选为可能包含 UserID 列值为 749927693 的行。</p>
<blockquote>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h5><p>当对作为组合主键的一部分且是第一个主键列进行查询过滤时，ClickHouse 将在主键列的索引标记上运行二分查找算法。</p>
</blockquote>
<p>如上所述，ClickHouse 正在使用其稀疏主键索引来快速（通过二分查找）选择可能包含与查询匹配的行的粒度组。</p>
<p>这是 ClickHouse 执行查询的<strong>第一阶段（粒度组选择）</strong>。</p>
<p>在<strong>第二阶段（数据读取）</strong>，ClickHouse 定位到选定的粒度组，以便将它们的所有行数据流式传输到 ClickHouse 引擎，从而找到实际匹配查询的行。</p>
<p>我们接下来将再更详细地讨论第二阶段。</p>
<h2 id="标记文件用于定位粒度组"><a href="#标记文件用于定位粒度组" class="headerlink" title="标记文件用于定位粒度组"></a>标记文件用于定位粒度组</h2><p>下图展示了我们表的主键索引文件的一部分。</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-04.png" alt="img"></p>
<p>如上所述，通过对索引的 1083 个UserID标记进行二分搜索，识别出标记 176。因此，其对应的粒度组176 可能包含 UserID 列值为 749.927.693 的行。</p>
<blockquote>
<p>粒度组选择细节</p>
<p>上图显示，标记 176 是第一个匹配的索引项，其中粒度组 176 的最小 UserID 值小于 749.927.693，并且下一个标记（标记 177）的粒度组177 的最小 UserID 值大于此值。因此，只有176 标记对应的粒度组可能包含 UserID 列值为 749.927.693 的行。</p>
</blockquote>
<p>为了确定（或不确定）粒度组 176 中的某些行包含 UserID 列值为749.927.693  ，属于该粒度组的所有 8192 行都需要流式传输到 ClickHouse。</p>
<p>为此，ClickHouse 需要知道粒度组 176 的物理位置。</p>
<p>在 ClickHouse 中，我们表的所有粒度组的物理位置都存储在标记文件中。与数据文件类似，每个列都有一个标记文件。</p>
<p>下图展示了三个标记文件 UserID.mrk、URL.mrk 和 EventTime.mrk，它们存储了表的 UserID、URL 和 EventTime 列的粒度组的物理位置。</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-05.png" alt="img"></p>
<p>我们已经讨论了主键索引为什么是一个扁平的未压缩数组文件 (primary.idx)，其中包含从 0 开始编号的索引标记。</p>
<p>同样，标记文件也是一个扁平未压缩的数组文件 (*.mrk)，其中包含从 0 开始编号的标记。</p>
<p>一旦 ClickHouse 识别并选择了可能包含查询匹配行的粒度组的索引标记，就可以在标记文件中执行查找数组位置，以获得粒度组的实际物理位置。</p>
<p>特定列的每个标记文件项都以偏移量的形式存储两个位置：</p>
<ul>
<li>第一个偏移量（上图中的“block_offset”）用于在<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>列数据文件中定位<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/development/architecture/#block">块</a>，包含所选粒度组的压缩版本。该压缩块可能包含一些压缩粒度组。定位的压缩文件块在读取时被解压到主内存中。</li>
<li>标记文件的第二个偏移量（上图中的“granule_offset”）提供了未压缩块数据中颗粒的位置。</li>
</ul>
<p>然后将被定位的未压缩粒度的所有 8192 行流式传输到 ClickHouse 以进行进一步处理。</p>
<blockquote>
<p><strong>为什么用标记文件</strong></p>
<p>为什么主索引不直接包含索引标记对应的粒度的物理位置？</p>
<p>因为在 ClickHouse 的非常大的数据规模下，十分重要的是磁盘和内存高效使用。</p>
<p>主索引文件需要加载到主内存。</p>
<p>对于我们的示例查询，ClickHouse 使用了主索引并选择了一个可能包含与我们的查询匹配的行的单个粒度。只有对于那个粒度，ClickHouse 才需要物理位置，以便流式传输相应的行以进行进一步处理。</p>
<p>此外，仅 UserID 和 URL 列需要此偏移信息。</p>
<p>查询中未使用的列不需要偏移信息，例如 EventTime。</p>
<p>对于我们的示例查询，Clickhouse 只需要 UserID 数据文件 (UserID.bin) 中粒度 176 的两个物理位置偏移量和 URL 数据文件 (URL.data) 中粒度 176 的两个物理位置偏移量。</p>
<p>标记文件的存在，间接地避免了在主索引中直接存储所有三列的所有 1083 个粒度的物理位置的条目：从而避免在主内存中存在不必要的（可能未使用的）数据。</p>
</blockquote>
<p>下图和下面的文本说明了我们的示例是如何查询 ClickHouse 在 UserID.bin 数据文件中定位粒度 176的。</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-06.png" alt="img"></p>
<p>我们在本文前面讨论过 ClickHouse选择了主索引标记 176，因此粒度 176 可能包含我们查询的匹配行。</p>
<p>ClickHouse 现在使用从索引中选择的标记编号 (176) 在 UserID.mrk 标记文件中进行数组的位置查找，以获得用于定位颗粒 176 的两个偏移量。</p>
<p>如图所示，第一个偏移量是在 UserID.bin 数据文件中定位压缩文件块，该文件包含粒度 176 的压缩版本。</p>
<p>一旦定位的文件块被解压到主内存中，标记文件的第二个偏移量可用于在未压缩数据中定位粒度176。</p>
<p>ClickHouse 需要从 UserID.bin 数据文件和 URL.bin 数据文件中定位（并从其中流式传输所有值）粒度 176 以执行我们的示例查询（UserID 为749.927. 693的互联网用户的前 10 个点击次数最多的 url )。</p>
<p>上图展示了 ClickHouse 如何定位 UserID.bin 数据文件的粒度。</p>
<p>此外，ClickHouse 对 URL.bin 数据文件的粒度 176 执行相同的操作。将两个各自的粒度对齐，并流式传输到 ClickHouse 引擎中进行进一步处理，即对 UserID 为 749.927.693 的所有行的每个组的 URL 值进行聚合和计数，最后按降序输出最大的 10 个 URL 组。</p>
<h1 id="使用多个主键索引"><a href="#使用多个主键索引" class="headerlink" title="使用多个主键索引"></a>使用多个主键索引</h1><h2 id="辅助键是否有效"><a href="#辅助键是否有效" class="headerlink" title="辅助键是否有效"></a>辅助键是否有效</h2><p>当查询对复合主键的一部分并且是第一个键列进行过滤时，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">ClickHouse 将在键列的索引标记上执行二分搜索算法</a>。</p>
<p>但是，当查询对复合主键的一部分但不是第一个键列进行过滤时会发生什么？</p>
<blockquote>
<p><strong>注意</strong></p>
<p>我们讨论一个查询保证不是在第一个键列上过滤，而是在辅助键列上过滤的场景。</p>
<p>当查询同时对第一个键列和第一个键列之后的任何键列进行过滤时，ClickHouse 将对第一个键列的索引标记执行二分搜索。</p>
</blockquote>
<p>我们使用一个查询来计算最常点击 URL”http ://public_search”的前 10 个用户：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.086 sec.
Processed 8.81 million rows,
799.69 MB (102.11 million rows/s., 9.27 GB/s.)</code></pre>
<p>客户端的输出表明 ClickHouse 几乎执行了全表扫描，尽管<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">URL 列作为复合主键的一部分</a>！ClickHouse 从表的 887 万行中读取了 881 万行。</p>
<p>如果启用了<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">trace_logging</a>，则 ClickHouse 服务器日志文件显示 了ClickHouse 对 1083 个 URL 索引标记使用了<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索</a>，以识别可能包含 URL 列值为“http: //public_search”的行的那些粒度：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 1 in ['http://public_search',
                                           'http://public_search'])
...Executor): Used generic exclusion search over index for part all_1_9_2
              with 1537 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              1076/1083 marks by primary key, 1076 marks to read from 5 ranges
...Executor): Reading approx. 8814592 rows with 10 streams</code></pre>
<p>我们可以在上面的示例跟踪日志中看到，1083 个粒度中的 1076 个（通过标记）被选择为可能包含具有匹配 URL 值的行。</p>
<p>这导致 881 万行被流式传输到 ClickHouse 引擎（并行使用 10 个流），以识别实际包含 URL 值“http: //public_search”的行。</p>
<p>然而，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-fast">正如我们稍后将看到</a>的那样，在选定的 1076 个粒度中只有 39 个粒度实际上包含匹配的行。</p>
<p>虽然基于复合主键 (UserID, URL) 的主索引对于加快具有特定 UserID 值的行的查询过滤非常有用，但该索引在加快过滤具有特定 URL 值的行的查询方面没有提供重要帮助。</p>
<p>原因是 URL 列不是第一个键列，因此 ClickHouse 在 URL 列的索引标记上使用通用排除搜索算法（而不是二分搜索），并且<strong>该算法的效率取决于</strong>URL 列和它的前置键列 UserID的 <strong>基数差异</strong>。</p>
<p>为了说明这一点，我们给出了一些关于通用排除搜索是如何执行的细节。</p>
<h2 id="通用排除搜索算法"><a href="#通用排除搜索算法" class="headerlink" title="通用排除搜索算法"></a>通用排除搜索算法</h2><p>下面说明了<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L14444">ClickHouse 通用排除搜索算法</a>在前置键列具有低（er）或高（er）基数的情况下，辅助键筛选粒度的工作原理。</p>
<p>作为这两种情况的示例，我们将假设：</p>
<ul>
<li>查询 URL 值 = “W3” 的行。</li>
<li>我们的 hits 表的抽象版本，其中包含 UserID 和 URL 的简化值。</li>
<li>索引的相同复合主键 (UserID, URL)。这意味着行首先按 UserID 值排序。然后按 URL 对具有相同 UserID 值的行进行排序。</li>
<li>粒度大小为 2，即每个粒度包含两行。</li>
</ul>
<p>我们在下图中用橙色标记了每个颗粒的最小键列值。</p>
<p><strong>前置键列的基数较低</strong></p>
<p>假设 UserID 具有低基数。在这种情况下，相同的 UserID 值很可能分布在多个表行和粒度上。对于具有相同 UserID 的索引标记，索引标记的 URL 值按升序排序（因为表行首先按 UserID 排序，然后按 URL 排序）。这能进行有效过滤，如下所示：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-07.png" alt="img"></p>
<p>上图中我们的抽象样本数据的粒度选择过程有三种不同的场景：</p>
<ol>
<li>由于标记索引0、1和2具有相同的UserID值，因此可以排除（最小）<strong>URL值小于W3并且直接后续索引标记的URL值也小于W3的索引标记0。</strong>请注意，此排除的前提是，确保了粒度 0 和下一个粒度1 完全由 U1的 UserID 值组成，因此 ClickHouse 可以推断粒度 0 中的最大 URL 值也小于 W3， 并排除该颗粒。</li>
<li>选择其<strong>URL 值小于（或等于）W3 并且其直接后续索引标记的 URL 值大于（或等于）W3</strong>的索引标记 1，因为这意味着粒度1 可能包含具有 URL值为W3 的行。</li>
<li><strong>可以排除URL 值大于 W3</strong>的索引标记 2 和 3 ，因为主键索引的索引标记存储每个粒度的最小键列值，因此粒度 2 和 3 不可能包含 URL 值为 W3的行。</li>
</ol>
<p><strong>前置键列的基数的较高</strong></p>
<p>当 UserID 具有高基数时，相同的 UserID 值不太可能分布在多个表行和粒度上。这意味着索引标记的 URL 值不是单调递增的：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-08.png" alt="img"></p>
<p>正如我们在上图中看到的，所有显示的 URL 值小于 W3 的标记都被选中，用于将其关联的粒度行都流式传输到 ClickHouse 引擎。</p>
<p>这是因为虽然图中的所有索引标记都属于上述场景 1，但它们不满足上述排除的前提条件，<em>即两个直接随后的索引标记都具有与当前标记相同的 UserID 值</em>，因此不能被排除.</p>
<p>例如，考虑索引标记 0 ，其<strong>URL 值小于 W3 并且直接后续索引标记的 URL 值也存在小于 W3</strong>。这<em>不能</em>排除，因为两个紧随其后的索引标记 1 和 2<em>没有</em>与当前标记 0 相同的 UserID 值。</p>
<p>请注意，要求两个后续索引标记具有相同的 UserID 值。这确保了当前和下一个标记的粒度完全由 U1的 UserID 值组成。如果只有下一个标记具有相同的 UserID，则下一个标记的 URL 值可能源自具有不同 UserID 的表行 - 当您查看上图时确实是这种情况，即 W2 源自 U2，而不是UserID 为U1的行。</p>
<p>这最终会阻止 ClickHouse 对粒度 0 中的最大 URL 值做出推断。相反，它必须假设粒度 0 可能包含 URL 值为 W3 的行，并被迫选择标记 0。</p>
<p>同理，标记 1、2 和 3 也是如此。</p>
<blockquote>
<p><strong>结论</strong></p>
<p>当查询对作为复合键的一部分但不是第一个键的列进行过滤，并且前置键列具有较低基数时，ClickHouse 使用<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索算法而不是</a><a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索算法</a>。</p>
</blockquote>
<p>在我们的示例数据集中，两个键列（UserID、URL）具有相似的高基数，并且如上所述，当 URL 列的前一个键列具有较高或相似的基数时，通用排除搜索算法并不是十分有效.</p>
<h2 id="注意跳数索引"><a href="#注意跳数索引" class="headerlink" title="注意跳数索引"></a>注意跳数索引</h2><p>由于 UserID 和 URL 值具有同样高的基数，在<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">使用复合主键 (UserID, URL)</a>的表上的URL列上创建<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">二级跳数索引</a>，并不会<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>有太大的帮助。</p>
<p>例如，以下两个语句在我们表的 URL 列上创建并填充了一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">minmax跳数索引：</a></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> url_skipping_index URL <span class="token keyword">TYPE</span> minmax GRANULARITY <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL MATERIALIZE <span class="token keyword">INDEX</span> url_skipping_index<span class="token punctuation">;</span></code></pre>
<p>ClickHouse 现在创建了一个附加索引，用于存储 - 每组 4 个连续<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">粒度</a>（注意上面ALTER TABLE语句中的GRANULARITY 4子句） - 的最小和最大 URL 值：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-13a.png" alt="img"></p>
<p>第一个索引项（上图中的“mark 0”）存储<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">表的前 4 个粒度的行</a>的最小和最大 URL 值。</p>
<p>第二个索引项（’mark 1’）存储表的后续 4 个粒度的行的最小和最大 URL 值，依此类推。</p>
<p>（ClickHouse 还为跳数索引创建了一个特殊的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>，用于<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">定位</a>与索引标记关联的粒度组。）</p>
<p>由于 UserID 和 URL 的基数同样高，所以当我们对 URL执行<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">查询过滤</a>时，这个二级跳数索引无法帮助排除被选中的粒度。</p>
<p>查询正在查找的特定 URL 值（如 “http: //public_search”）很可能介于索引为每组粒度存储的最小值和最大值之间，导致 ClickHouse 被迫选择粒度组（因为它们可能包含与查询匹配的行）。</p>
<h2 id="需要使用多个主键索引"><a href="#需要使用多个主键索引" class="headerlink" title="需要使用多个主键索引"></a>需要使用多个主键索引</h2><p>因此，如果我们想要显着加快过滤具有特定 URL 的行的示例查询，那么我们需要使用针对该查询优化的主键索引。</p>
<p>此外，如果我们希望保持过滤具有特定 UserID 的行的示例查询的良好性能，那么我们需要使用多个主键索引。</p>
<p>以下是实现这一目标的方法。</p>
<h2 id="用于创建附加主键索引的选项"><a href="#用于创建附加主键索引的选项" class="headerlink" title="用于创建附加主键索引的选项"></a>用于创建附加主键索引的选项</h2><p>如果我们想显着加快我们的两个示例查询 - 一个过滤具有特定 UserID 的行和一个过滤具有特定 URL 的行 - 那么我们需要通过使用这三个选项之一来使用多个主索引：</p>
<ul>
<li>使用不同的主键创建<strong>第二个表。</strong></li>
<li>在我们现有的表上创建一个<strong>物化视图。</strong></li>
<li>向我们现有的表添加<strong>投影。</strong></li>
</ul>
<p>所有的三个选项都会有效地将我们的样本数据复制到一个附加表中，以便重新组织表的主键索引和行排序顺序。</p>
<p>但是，这三个选项的不同之处在于附加表对于用户查询和插入语句处理的方便程度。</p>
<p>当创建了具有不同主键的<strong>第二个表</strong>后，必须将查询显式发送到最适合查询的表中，并且必须将新数据显式插入两个表中以保持表同步：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-09a.png" alt="img"></p>
<p>使用<strong>物化视图</strong>会隐式创建附加表，并且两个表之间的数据会自动保持同步：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-09b.png" alt="img"></p>
<p><strong>投影</strong>是最方便的选项，因为除了自动保持隐式创建（和隐藏）附加表与同步数据更改之外，ClickHouse 将自动选择最有效的表版本进行查询：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-09c.png" alt="img"></p>
<p>在下文中，我们将通过实例来更详细地讨论创建和使用多个主索引的这三个选项。</p>
<h2 id="选项-1：辅助表"><a href="#选项-1：辅助表" class="headerlink" title="选项 1：辅助表"></a>选项 1：辅助表</h2><p>创建一个新的附加表，在主键中切换了键列的顺序（与原始表相比）：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_URL_UserID
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<p>将<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>中的所有的 887 万行数据插入到附加表中：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_URL_UserID
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 2.898 sec. Processed 8.87 million rows, 838.84 MB (3.06 million rows/s., 289.46 MB/s.)</code></pre>
<p>最后优化表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_URL_UserID FINAL<span class="token punctuation">;</span></code></pre>
<p>因为我们切换了主键中列的顺序，插入的行现在以不同的字典顺序存储在磁盘上（与我们的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>相比），因此该表的 1083 个粒度包含与之前不同的值：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-10.png" alt="img"></p>
<p>这是生成的主键：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-11.png" alt="img"></p>
<p>现在可以使用它来显着加快我们对 URL 列的示例查询过滤，以计算最常点击的 URL”http: //public_search”的前 10 个用户：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_URL_UserID
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.017 sec.
Processed 319.49 thousand rows,
11.38 MB (18.41 million rows/s., 655.75 MB/s.)</code></pre>
<p>现在， ClickHouse<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#filtering-on-key-columns-after-the-first">没有进行全表扫描</a>，而是更有效地执行了该查询。</p>
<p>当使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>的主索引时，其中 UserID 是第一个，URL 是第二个键列，ClickHouse 对索引标记使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-algorithm">通用排除搜索</a>来执行该查询。并且由于 UserID 和URL具有同样高的基数，使得该查询并不高效。</p>
<p>将 URL 作为主索引中的第一列，ClickHouse 现在对索引标记运行<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索</a>。ClickHouse 服务器日志文件中的相应跟踪日志也验证了这一点：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)
...Executor): Found (LEFT) boundary mark: 644
...Executor): Found (RIGHT) boundary mark: 683
...Executor): Found continuous range in 19 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              39/1083 marks by primary key, 39 marks to read from 1 ranges
...Executor): Reading approx. 319488 rows with 2 streams</code></pre>
<p>ClickHouse 仅选择了 39 个索引标记，而不是使用通用排除搜索时的 1076 个。</p>
<p>请注意，附加表经过优化，可加快我们对 URL 的示例查询过滤的执行速度。</p>
<p>与使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>时该查询的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-slow">性能不佳</a>同理，我们对 UserID 的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">示例查询过滤</a>在新的附加表中不会有效地执行，因为 UserID 现在是该表主键索引中的第二个键列，因此 ClickHouse 将使用粒度选择的通用排除搜索，对于相似高基数的 UserID 和 URL列<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不是很有效</a>。以下为详细信息。</p>
<blockquote>
<p>对 UserID 的查询过滤现在性能很差</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_URL_UserID
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.024 sec.
Processed 8.02 million rows,
73.04 MB (340.26 million rows/s., 3.10 GB/s.)</code></pre>
<p>服务器日志</p>
<pre class=" language-log"><code class="language-log">...Executor): Key condition: (column 1 in [749927693, 749927693])
...Executor): Used generic exclusion search over index for part all_1_9_2
           with 1453 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
           980/1083 marks by primary key, 980 marks to read from 23 ranges
...Executor): Reading approx. 8028160 rows with 10 streams</code></pre>
</blockquote>
<p>我们现在有两张表。分别针对 UserID 的查询过滤和对 URL 的查询过滤进行了优化加速：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-12a.png" alt="img"></p>
<h2 id="选项-2：物化视图"><a href="#选项-2：物化视图" class="headerlink" title="选项 2：物化视图"></a>选项 2：物化视图</h2><p>在我们现有的表上创建一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">物化视图</a>。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> MATERIALIZED <span class="token keyword">VIEW</span> mv_hits_URL_UserID
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
POPULATE
<span class="token keyword">AS</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 2.935 sec. Processed 8.87 million rows, 838.84 MB (3.02 million rows/s., 285.84 MB/s.)</code></pre>
<blockquote>
<p>注意</p>
<ul>
<li>我们在视图中的主键切换了主键列的顺序（与我们的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表相比）</a></li>
<li>物化视图由<strong>隐式创建的表</strong>支持，该表的行顺序和主键索引基于给定的主键定义</li>
<li>隐式创建的表由SHOW TABLES查询列出，名称以.inner 开头</li>
<li>也可以首先显式地为物化视图创建依赖表，然后视图可以通过TO [db].[table] <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">子句</a>定位该表。</li>
<li>我们使用POPULATE关键字来立即使用887 万行的源表<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>来填充隐式创建表</li>
<li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐式创建的表中</li>
<li>实际上，隐式创建的表与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主索引：</li>
</ul>
</blockquote>
<p><img src="%5Cimages%5Csparse-primary-indexes-12b-1.png" alt="img"></p>
<p>ClickHouse 将隐式创建的表的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在 ClickHouse 服务器数据目录的特殊文件夹中：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-12b-2.png" alt="img"></p>
<p>支持物化视图的隐式创建的表（以及它的主索引）现在可用于显着加快我们对 URL 列的示例查询过滤的执行速度：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> mv_hits_URL_UserID
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.026 sec.
Processed 335.87 thousand rows,
13.54 MB (12.91 million rows/s., 520.38 MB/s.)</code></pre>
<p>因为实际上支持物化视图的隐式创建的表（以及它的主索引）与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p>
<p>ClickHouse 服务器日志文件中的相应跟踪日志验证了 ClickHouse 正在对索引标记执行二分搜索：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range ...
...
...Executor): Selected 4/4 parts by partition key, 4 parts by primary key,
              41/1083 marks by primary key, 41 marks to read from 4 ranges
...Executor): Reading approx. 335872 rows with 4 streams</code></pre>
<h2 id="选项-3：投影"><a href="#选项-3：投影" class="headerlink" title="选项 3：投影"></a>选项 3：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#option-3-projections">投影</a></h2><p>在我们现有的表上创建一个投影：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL
    <span class="token keyword">ADD</span> PROJECTION prj_url_userid
    <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> <span class="token operator">*</span>
        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>并实现投影：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL
    MATERIALIZE PROJECTION prj_url_userid<span class="token punctuation">;</span></code></pre>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>投影创建一个<strong>隐藏表</strong>，其行顺序和主键索引基于投影给定的ORDER BY子句</li>
<li>SHOW TABLES查询不能列出隐藏的投影表</li>
<li>我们使用MATERIALIZE关键字，以便立即使用源表<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>中的所有 887 万行填充隐藏表</li>
<li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐藏表中</li>
<li>查询始终（在语法上）以源表 hits_UserID_URL 为目标，但如果隐藏表的行顺序和主索引允许更有效的查询执行，则将使用该隐藏表代替</li>
<li>实际上，隐式创建的隐藏表与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主键索引：</li>
</ul>
</blockquote>
<p><img src="%5Cimages%5Csparse-primary-indexes-12c-1.png" alt="img"></p>
<p>ClickHouse 将隐藏表的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在源表数据文件、标记文件和主索引文件旁边的特殊文件夹中（在下面的截图中标记为橙色）：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-12c-2.png" alt="img"></p>
<p>由投影创建的隐藏表（以及它的主键索引）现在可以（隐式地）用于显着加快我们在 URL 列上执行示例查询过滤的速度。请注意，查询在语法上以投影的源表为目标。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.029 sec.
Processed 319.49 thousand rows, 1
1.38 MB (11.05 million rows/s., 393.58 MB/s.)</code></pre>
<p>由于投影创建的隐藏表（以及它的主索引）实际上与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p>
<p>ClickHouse 服务器日志文件中的相应跟踪日志证实了ClickHouse 正在对索引标记执行二分搜索：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range for part prj_url_userid (1083 marks)
...Executor): ...
...Executor): Choose complete Normal projection prj_url_userid
...Executor): projection required columns: URL, UserID
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              39/1083 marks by primary key, 39 marks to read from 1 ranges
...Executor): Reading approx. 319488 rows with 2 streams</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">具有复合主键 (UserID, URL)的表</a>的主键索引对于加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">UserID 的查询过滤</a>非常有用。但是，尽管 URL 列是复合主键的一部分，但该索引并没有为加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url"> URL 的查询过滤</a>提供重要帮助。</p>
<p>反之亦然：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#secondary-table">具有复合主键 (URL, UserID) 的表</a>的主键索引能加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>，但<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">对 UserID的查询过滤</a>没有提供太多帮助。</p>
<p>由于主键列 UserID 和 URL 具有相似的高基数，对第二个键列进行过滤的查询<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不会从索引中的第二个键列中获得太多帮助</a>。</p>
<p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes">因此，从主索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主索引</a>是有意义的。</p>
<p>但是，如果复合主键中的键列在基数上有很大差异，则<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-fast">查询</a>按基数升序排列主键列是有益的。</p>
<p>键列之间的基数差异越大，这些列在键中的顺序就越重要。我们将在下一节中证明这一点。</p>
<p>因此，从主键索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主键索引是有意义的。</p>
<p>但是，如果复合主键中的键列在基数上有很大差异，则按基数升序排列的主键列对查询是有帮助的。</p>
<p>键列之间的基数差异越大，这些列在键中的顺序就越重要。 我们将在下一节中说明这一点。</p>
<h1 id="有效地对键列进行排序"><a href="#有效地对键列进行排序" class="headerlink" title="有效地对键列进行排序"></a>有效地对键列进行排序</h1><p>在复合主键中，键列的顺序会明显影响以下两点：</p>
<ul>
<li>查询中辅助键列的过滤效率，以及</li>
<li>表的数据文件的压缩率。</li>
</ul>
<p>为了证明这一点，我们将使用我们的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-intro/#data-set">网络流量示例数据集</a>的一个版本， 其中每行包含三列，代表互联网“用户”（<code>UserID</code>列）对 URL（<code>URL</code>列）的访问是否被标记为机器人流量（<code>IsRobot</code>列）。</p>
<p>我们将使用包含所有上述三个列的复合主键，可用于加速典型的 Web 分析查询</p>
<ul>
<li>到特定 URL 的流量有多少（百分比）来自机器人</li>
<li>我们判断特定用户是否为机器人的准确程度（来自该用户的流量有多少百分比是否被假定为机器人流量）</li>
</ul>
<p>我们使用此查询来计算要用作复合主键中的键列的三列的基数（请注意，我们正在使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/table-functions/url">URL 表函数</a>来临时查询 TSV 数据，而无需创建本地表） . 在<code>clickhouse client</code>运行此查询：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    formatReadableQuantity<span class="token punctuation">(</span>uniq<span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> cardinality_URL<span class="token punctuation">,</span>
    formatReadableQuantity<span class="token punctuation">(</span>uniq<span class="token punctuation">(</span>UserID<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> cardinality_UserID<span class="token punctuation">,</span>
    formatReadableQuantity<span class="token punctuation">(</span>uniq<span class="token punctuation">(</span>IsRobot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> cardinality_IsRobot
<span class="token keyword">FROM</span>
<span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        <span class="token number">c11</span>::UInt64 <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
        <span class="token number">c15</span>::String <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
        <span class="token number">c20</span>::UInt8 <span class="token keyword">AS</span> IsRobot
    <span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
    <span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span>
<span class="token punctuation">)</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─cardinality_URL─┬─cardinality_UserID─┬─cardinality_IsRobot─┐
│ 2.39 million    │ 119.08 thousand    │ 4.00                │
└─────────────────┴────────────────────┴─────────────────────┘

1 row in set. Elapsed: 118.334 sec. Processed 8.87 million rows, 15.88 GB (74.99 thousand rows/s., 134.21 MB/s.)</code></pre>
<p>我们可以看到基数之间存在很大差异，尤其是<code>URL</code>和<code>IsRobot</code>列之间。因此复合主键中列的顺序，对于有效加快对该列的查询过滤和实现最佳表的列数据文件压缩比都十分重要。</p>
<p>为了说明这一点，流量分析数据创建了两个表版本：</p>
<ul>
<li>具有复合主键<code>(URL, UserID, IsRobot)</code>的表<code>hits_URL_UserID_IsRobot</code>，我们按基数降序对键列进行排序</li>
<li>具有复合主键<code>(IsRobot, UserID, URL)</code>的表<code>hits_IsRobot_UserID_URL</code>，我们按基数升序对键列进行排序</li>
</ul>
<p>使用复合主键<code>(URL, UserID, IsRobot)</code>创建表<code>hits_URL_UserID_IsRobot</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_URL_UserID_IsRobot
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>IsRobot<span class="token punctuation">`</span> UInt8
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> IsRobot<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>并用 887 万行填充它：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_URL_UserID_IsRobot <span class="token keyword">SELECT</span>
    intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
    <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
    <span class="token number">c20</span> <span class="token keyword">AS</span> IsRobot
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">0 rows in set. Elapsed: 104.729 sec. Processed 8.87 million rows, 15.88 GB (84.73 thousand rows/s., 151.64 MB/s.)</code></pre>
<p>接下来，使用复合主键<code>(IsRobot, UserID, URL)</code>创建表<code>hits_IsRobot_UserID_URL</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_IsRobot_UserID_URL
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>IsRobot<span class="token punctuation">`</span> UInt8
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>IsRobot<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> URL<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>并用我们填充上一个表的相同的 887 万行来填充它：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_IsRobot_UserID_URL <span class="token keyword">SELECT</span>
    intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
    <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
    <span class="token number">c20</span> <span class="token keyword">AS</span> IsRobot
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">0 rows in set. Elapsed: 95.959 sec. Processed 8.87 million rows, 15.88 GB (92.48 thousand rows/s., 165.50 MB/s.)</code></pre>
<h2 id="对辅助键列的有效过滤"><a href="#对辅助键列的有效过滤" class="headerlink" title="对辅助键列的有效过滤"></a>对辅助键列的有效过滤</h2><p>当查询过滤在作为复合键的一部分并且是第一个键列的至少一列上时，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">ClickHouse 将在键列的索引标记上运行二分搜索算法</a>。</p>
<p>当查询（仅）对作为复合键的一部分但不是第一个键列的列进行过滤时，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#secondary-key-columns-can-not-be-inefficient">ClickHouse 将在键列的索引标记上使用通用排除搜索算法</a>。</p>
<p>对于第二种情况，复合主键中键列的排序对于<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索算法</a>的高效性非常重要。</p>
<p>这是一个过滤<code>UserID</code>列的查询，其中表<code>(URL, UserID, IsRobot)</code>按基数降序对键列进行排序：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> hits_URL_UserID_IsRobot
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">112304</span></code></pre>
<p>响应为：</p>
<pre class=" language-response"><code class="language-response">┌─count()─┐
│      73 │
└─────────┘

1 row in set. Elapsed: 0.026 sec.
Processed 7.92 million rows, 
31.67 MB (306.90 million rows/s., 1.23 GB/s.)</code></pre>
<p>这是对表<code>(IsRobot, UserID, URL)</code>执行的相同查询，其中表按基数升序对键列进行排序：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> hits_IsRobot_UserID_URL
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">112304</span></code></pre>
<p>响应是：</p>
<pre class=" language-response"><code class="language-response">┌─count()─┐
│      73 │
└─────────┘

1 row in set. Elapsed: 0.003 sec.
Processed 20.32 thousand rows, 
81.28 KB (6.61 million rows/s., 26.44 MB/s.)</code></pre>
<p>我们可以看到，在我们按基数以升序对键列进行排序的表上，查询执行明显更有效、更快。</p>
<p>原因是<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索算法</a>最有效，当通过辅助键列选择<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">粒度</a>时，前导键列具有较低的基数。我们在本指南的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-algorithm">前一节中详细说明了这一点。</a></p>
<h2 id="数据文件的最佳压缩率"><a href="#数据文件的最佳压缩率" class="headerlink" title="数据文件的最佳压缩率"></a>数据文件的最佳压缩率</h2><p>此查询比较我们在上面创建的两个表之间的<code>UserID</code>列的压缩率：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    <span class="token keyword">table</span> <span class="token keyword">AS</span> <span class="token keyword">Table</span><span class="token punctuation">,</span>
    name <span class="token keyword">AS</span> <span class="token keyword">Column</span><span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_uncompressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> Uncompressed<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_compressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> Compressed<span class="token punctuation">,</span>
    <span class="token function">round</span><span class="token punctuation">(</span>data_uncompressed_bytes <span class="token operator">/</span> data_compressed_bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> Ratio
<span class="token keyword">FROM</span> system<span class="token punctuation">.</span><span class="token keyword">columns</span>
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span><span class="token keyword">table</span> <span class="token operator">=</span> <span class="token string">'hits_URL_UserID_IsRobot'</span> <span class="token operator">OR</span> <span class="token keyword">table</span> <span class="token operator">=</span> <span class="token string">'hits_IsRobot_UserID_URL'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'UserID'</span><span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Ratio <span class="token keyword">ASC</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─Table───────────────────┬─Column─┬─Uncompressed─┬─Compressed─┬─Ratio─┐
│ hits_URL_UserID_IsRobot │ UserID │ 33.83 MiB    │ 11.24 MiB  │     3 │
│ hits_IsRobot_UserID_URL │ UserID │ 33.83 MiB    │ 877.47 KiB │    39 │
└─────────────────────────┴────────┴──────────────┴────────────┴───────┘

2 rows in set. Elapsed: 0.006 sec. </code></pre>
<p>我们可以看到，对于我们按基数以升序对键列<code>(IsRobot, UserID, URL)</code>进行排序的表，<code>UserID</code>列的压缩率明显更高。</p>
<p>尽管在两个表中存储了完全相同的数据（我们在两个表中插入了相同的 887 万行），但复合主键中键列的顺序对表的列<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">数据文件</a>中的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>数据占用多少磁盘空间有很大影响：</p>
<ul>
<li>在具有复合主键<code>(URL, UserID, IsRobot)</code>的表<code>hits_URL_UserID_IsRobot</code>中，我们按基数降序排列键列，<code>UserID.bin</code>数据文件占用<strong>11.24 MiB</strong>的磁盘空间</li>
<li>在具有复合主键<code>(IsRobot, UserID, URL)</code>的表<code>hits_IsRobot_UserID_URL</code>中，我们按基数升序对键列进行排序，<code>UserID.bin</code>数据文件仅占用<strong>877.47 KiB</strong>磁盘空间</li>
</ul>
<p>磁盘上的表列数据具有良好的压缩比不仅可以节省磁盘空间，而且还可以使需要从该列读取数据的查询（尤其是分析查询）更快，因为从磁盘到主存（操作系统的文件缓存）移动列的数据所需的 i/o 更少。</p>
<p>下面我们将说明为什么主键按基数升序排列对表列的压缩率有好处。</p>
<p>下图描绘了主键在磁盘上的行顺序，其中键列按基数升序排列：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-14a.png" alt="img"></p>
<p>我们说明了<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">表的行数据按主键列排序存储在磁盘上</a>。</p>
<p>在上图中，表的行（它们在磁盘上的列值）首先按<code>cl</code>值排序，具有相同<code>cl</code>值的行按其<code>ch</code>值排序。并且由于第一个键列<code>cl</code>的基数较低，很可能存在具有相同<code>cl</code>值的行。因此，<code>ch</code>值也可能是有序的（局部 - 对于具有相同<code>cl</code>值的行）。</p>
<p>如果在一列中，相似的数据彼此靠近放置，例如通过排序，那么该数据将被更好地进行压缩。一般来说，压缩算法受益于数据的长度（数据越多，压缩效果越好）和局部性（数据越相似，压缩比越好）。</p>
<p>与上图相反，下图描绘了磁盘上行顺序按主键基数降序排列：</p>
<p><img src="%5Cimages%5Csparse-primary-indexes-14b.png" alt="img"></p>
<p>现在表的行首先按它们的<code>ch</code>值排序，具有相同<code>ch</code>值的行按它们的<code>cl</code>值排序。但是因为第一个键列<code>ch</code>的基数很高，所以不可能有相同<code>ch</code>值的行。并且因此也不太可能对<code>cl</code>值进行排序（局部 - 对于具有相同<code>ch</code>值的行）。</p>
<p>因此，这些<code>cl</code>值很可能是随机顺序的，因此分别具有较差的局部性和压缩比。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对于提升查询中的辅助键列的有效过滤和表的列数据文件的压缩率，将主键中的列按其基数升序排列是有帮助的。</p>
<h1 id="有效识别单行"><a href="#有效识别单行" class="headerlink" title="有效识别单行"></a>有效识别单行</h1><p>虽然通常它<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/faq/use-cases/key-value">不是</a>ClickHouse 的最佳用例，但有时在 构建ClickHouse 之上的应用程序需要识别 ClickHouse 表的单行。</p>
<p>一个直观的解决方案是使用每行具有唯一值的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>列，并将该列用作主键列以快速检索行。</p>
<p>为了最快的检索，UUID 列<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">需要是第一个键列</a>。</p>
<p>我们讨论了因为<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">ClickHouse 表的行数据存储在按主键列排序的磁盘上</a>，因此在主键或复合主键中具有非常高的基数的列（如 UUID 列）在具有较低基数的列之外<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-cardinality/#optimal-compression-ratio-of-data-files">是不利于表列的压缩比</a>。</p>
<p>最快检索和最佳数据压缩之间的折衷方案是使用复合主键，其中 UUID 是最后一个键列，位于用于确保某些表列的良好压缩比的低基数键列之后。</p>
<h1 id="一个具体的例子"><a href="#一个具体的例子" class="headerlink" title="一个具体的例子"></a>一个具体的例子</h1><p>一个具体的例子是Alexey Milovidov 开发并<a target="_blank" rel="noopener" href="https://clickhouse.com/blog/building-a-paste-service-with-clickhouse/">提到</a>的文本粘贴服务<a target="_blank" rel="noopener" href="https://pastila.nl/">https://pastila.nl</a>。</p>
<p>每次更改文本区域时，数据都会自动保存到 ClickHouse 表行（每次更改一行）。</p>
<p>识别和检索（特定版本）粘贴内容的一种方法是使用内容的hash作为包含该内容的表行的 UUID。</p>
<p>下图说明</p>
<ul>
<li>内容更改时行的插入顺序（例如，由于在文本区域中输入文本）和</li>
<li>使用<code>PRIMARY KEY (hash)</code>时插入的行数据在磁盘上的顺序：<img src="/images/sparse-primary-indexes-15a.png" alt="img"></li>
</ul>
<p>因为该<code>hash</code>列被用作主键列</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">可以非常快速</a>地检索特定的行，但是</li>
<li>表的行（它们的列数据）按（唯一和随机）哈希值升序排列存储在磁盘上。因此，内容列的值也以随机顺序存储，没有数据局部性，导致<strong>内容列数据文件的压缩率次优</strong>。</li>
</ul>
<p>为了显着提高内容列的压缩率，同时仍然实现对特定行的快速检索，pasila.nl 使用两个哈希值（和一个复合主键）来识别特定行：</p>
<ul>
<li>如上所述，内容的哈希值对于不同的数据是不同的，以及</li>
<li>一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing">局部敏感的hash（指纹）</a>，<strong>不</strong>会因数据的微小变化而改变。</li>
</ul>
<p>下图显示</p>
<ul>
<li>内容更改时行的插入顺序（例如，由于在文本区域中输入文本）和</li>
<li>使用复合主键<code>PRIMARY KEY (fingerprint, hash)</code>时插入行数据在磁盘上的顺序：</li>
</ul>
<p><img src="%5Cimages%5Csparse-primary-indexes-15b.png" alt="img"></p>
<p>现在磁盘上的行首先按<code>fingerprint</code>排序，对于具有相同指纹值的行，它们的<code>hash</code>值决定了最终的顺序。</p>
<p>因为只有微小变化的数据会获得相同的指纹值，所以现在相似的数据存储在磁盘上的内容列中彼此靠近。这对内容列的压缩率非常有利，因为压缩算法通常受益于数据局部性（数据越相似，压缩率越好）。</p>
<p>折衷方案是检索特定行需要两个字段 (<code>fingerprint</code>和<code>hash</code>)，以便最佳地利用产生的复合主索引<code>PRIMARY KEY (fingerprint, hash)</code>。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://onehr7.github.io/2022/11/02/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95/" title="ClickHouse优化（译） -- 主键索引" target="_blank" rel="external">https://onehr7.github.io/2022/11/02/ClickHouse优化（译） -- 主键索引/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Onehr7" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Onehr7" target="_blank"><span class="text-dark">mortal</span><small class="ml-1x"></small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/11/04/ClickHouse%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%91%EF%BC%89%20--%20%E8%B7%B3%E6%95%B0%E7%B4%A2%E5%BC%95/" title="ClickHouse优化（译） -- 跳数索引"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/01/10/Kafka%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Kafka三节点集群搭建"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Onehr7" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'cf74f9ce49741617bcff',
    clientSecret: 'c75adc2334e996980ecd8c0eaa329e74e82c407f',
    repo: 'comment',
    owner: 'Onehr7',
    admin: ['Onehr7'],
    id: md5(location.pathname),
    distractionFreeMode: true,
    language: 'zh-CN',
    enableHotKey: 'true'
  })
  gitalk.render('comments')
  </script>
      







</body>
</html>