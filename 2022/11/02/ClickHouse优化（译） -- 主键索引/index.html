<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ClickHouse优化（译） -- 主键索引"><meta name="keywords" content=""><meta name="author" content="Hairui Wang"><meta name="copyright" content="Hairui Wang"><title>ClickHouse优化（译） -- 主键索引 | null</title><link rel="shortcut icon" href="https://i.loli.net/2021/01/14/e3vagq7WDQYRb2u.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ef7a543c3e7a72310eea0007355b0331";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ClickHouse-%E7%A8%80%E7%96%8F%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.</span> <span class="toc-text">ClickHouse 稀疏主键索引的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-number">1.2.</span> <span class="toc-text">数据集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">测试机器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">1.4.</span> <span class="toc-text">全表扫描</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ClickHouse-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">ClickHouse 索引设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E4%B8%8B%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">海量数据规模下的索引设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E4%B8%BB%E9%94%AE%E7%9A%84%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">具有主键的表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%89%E4%B8%BB%E9%94%AE%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A"><span class="toc-number">2.3.</span> <span class="toc-text">数据按主键列顺序存储在磁盘上</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.0.0.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A2%AB%E5%88%86%E6%88%90%E7%B2%92%E5%BA%A6%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">数据被分成粒度以进行并行数据处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%AF%8F%E4%B8%AA%E7%B2%92%E5%BA%A6%E7%BB%84%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E9%A1%B9"><span class="toc-number">2.5.</span> <span class="toc-text">主键索引每个粒度组有一个索引项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%94%A8%E4%BA%8E%E9%80%89%E6%8B%A9%E7%B2%92%E5%BA%A6%E7%BB%84"><span class="toc-number">2.6.</span> <span class="toc-text">主键索引用于选择粒度组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.6.0.0.1.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%96%87%E4%BB%B6%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%BD%8D%E7%B2%92%E5%BA%A6%E7%BB%84"><span class="toc-number">2.7.</span> <span class="toc-text">标记文件用于定位粒度组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">使用多个主键索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E9%94%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">3.1.</span> <span class="toc-text">辅助键是否有效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%8E%92%E9%99%A4%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">通用排除搜索算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E8%B7%B3%E6%95%B0%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.</span> <span class="toc-text">注意跳数索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.</span> <span class="toc-text">需要使用多个主键索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E9%99%84%E5%8A%A0%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">3.5.</span> <span class="toc-text">用于创建附加主键索引的选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-1%EF%BC%9A%E8%BE%85%E5%8A%A9%E8%A1%A8"><span class="toc-number">3.6.</span> <span class="toc-text">选项 1：辅助表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-2%EF%BC%9A%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">3.7.</span> <span class="toc-text">选项 2：物化视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-3%EF%BC%9A%E6%8A%95%E5%BD%B1"><span class="toc-number">3.8.</span> <span class="toc-text">选项 3：投影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/01/14/STbxQl9M7XLJUkY.jpg"></div><div class="author-info__name text-center">Hairui Wang</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/Onehr7">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://leetcode-cn.com/u/edocteel-3/">Leetcode</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/01/14/aJn4RNHLOvf3dDj.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/"></a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">ClickHouse优化（译） -- 主键索引</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/ClickHouse/">ClickHouse</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes">原文</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="ClickHouse-稀疏主键索引的最佳实践"><a href="#ClickHouse-稀疏主键索引的最佳实践" class="headerlink" title="ClickHouse 稀疏主键索引的最佳实践"></a>ClickHouse 稀疏主键索引的最佳实践</h2><p>在本文中，我们将深入研究 ClickHouse 索引。我们将详细说明以下问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#an-index-design-for-massive-data-scales">ClickHouse 中的索引与传统的关系型数据库索引有何不同</a></li>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#a-table-with-a-primary-key">ClickHouse是 如何构建和使用表的稀疏主键索引的</a></li>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple">在 ClickHouse 中建立索引的一些最佳案例是什么</a></li>
</ul>
<a id="more"></a>

<p>您可以选择在自己的机器上自行执行本文中给出的所有 ClickHouse SQL 语句和查询。有关 ClickHouse 的安装和入门说明，请参阅<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/quick-start">快速入门</a>。</p>
<blockquote>
<p>本文重点介绍 ClickHouse 稀疏主键索引。</p>
<p>对于 ClickHouse<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#table_engine-mergetree-data_skipping-indexes">跳数索引</a>，请参阅此<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">教程</a>。</p>
</blockquote>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>通过本次教程，我们将使用一个匿名的Web 流量数据集作为示例。</p>
<ul>
<li>我们将使用样本数据集中 887 万行（事件）的子数据集。</li>
<li>未压缩的数据大小大约为 700 MB，并包含887 万个事件。当存储在 ClickHouse 中时，它会被压缩到 200 MB。</li>
<li>在我们的子数据集中，每行包含三列：网络用户（<code>UserID</code>）在特定时间（<code>EventTime</code>）点击了一条URL（<code>URL</code>）</li>
</ul>
<p>通过这三列，我们已经可以制定一些典型的 Web 分析查询，例如：</p>
<ul>
<li>指定用户的点击次数排名前10的网址是哪些？</li>
<li>指定URL 的前10 位活跃用户是哪些？</li>
<li>用户点击指定URL 的最通常的时间（例如一周中的哪几天）是什么时候？</li>
</ul>
<h2 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h2><p>本文档给出的所有运行数据，均基于在配备 Apple M1 Pro 芯片和 16GB RAM 的 MacBook Pro 上本地运行的ClickHouse 22.2.1。</p>
<h2 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h2><p>为了展现如何在不使用主键的情况下，对我们的数据集执行查询。我们通过执行以下 SQL DDL 语句来创建一个表（使用 MergeTree 表引擎）：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> tuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>接下来使用以下 SQL 插入语句将hits数据集的子数据插入到表中。通过<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/table-functions/url/">URL 表函数</a>与<a target="_blank" rel="noopener" href="https://clickhouse.com/blog/whats-new-in-clickhouse-22-1/#schema-inference">结构推断</a>结合使用，以加载在 clickhouse.com 远程托管的完整数据集的子集：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_NoPrimaryKey <span class="token keyword">SELECT</span>
   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 145.993 sec. Processed 8.87 million rows, 18.40 GB (60.78 thousand rows/s., 126.06 MB/s.)</code></pre>
<p>ClickHouse 客户端的输出结果表明，上面的语句向表中成功写入了 887 万行。</p>
<p>最后，为了简化本文后面的讨论，并使图表和结果可重现，我们使用 FINAL 关键字[<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/optimize">optimize</a>] 表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_NoPrimaryKey FINAL<span class="token punctuation">;</span></code></pre>
<blockquote>
<p>通常，不需要也不建议在将数据加载到表后立即对其进行optimize 。但这对于这个例子为什么有必要则是显而易见的。</p>
</blockquote>
<p>现在执行我们的第一个web分析查询。以下是计算 ID 为 749927693 的互联网用户的点击次数前 10 的网址：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">as</span> Count
<span class="token keyword">FROM</span> hits_NoPrimaryKey
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>结果如下：</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.022 sec.
Processed 8.87 million rows,
70.45 MB (398.53 million rows/s., 3.17 GB/s.)</code></pre>
<p>ClickHouse 客户端的输出结果表明， ClickHouse 执行了全表扫描！我们表的 887 万行中的每一行都流式传输到了ClickHouse。这是行不通的。</p>
<p>为了使这种查询更有效并且更快，我们需要使用具有适当主键的表。这将允许 ClickHouse 自动（基于主键的列）创建稀疏主键索引，然后可以使用该索引明显加快示例查询的执行速度。</p>
<hr>
<h1 id="ClickHouse-索引设计"><a href="#ClickHouse-索引设计" class="headerlink" title="ClickHouse 索引设计"></a>ClickHouse 索引设计</h1><h2 id="海量数据规模下的索引设计"><a href="#海量数据规模下的索引设计" class="headerlink" title="海量数据规模下的索引设计"></a>海量数据规模下的索引设计</h2><p>在传统的关系型数据库中，表的每一行都包含一个主键索引。对于我们的数据集，这将导致主键索引: 通常是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%2B_tree">B(+)-Tree</a>数据结构，包含 887 万条。</p>
<p>这样的索引可以快速定位指定行，从而提高查询和定点更新的效率。在 B(+)-Tree 数据结构中查找索引的平均时间复杂度为O(log2 n)。对于 887 万行的表，这意味着只需要23 次搜索就能定位任何索引项。</p>
<p>这种能力是有代价的：在向表添加新行和向索引中添加项时（有时还会重新平衡 B-Tree），会产生额外的磁盘和内存开销，以及更高的插入成本。</p>
<p>考虑到与 B-Tree 索引相关的挑战，ClickHouse 中的表引擎采用了不同的方法。ClickHouse <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/">MergeTree 引擎系列</a>经过设计和优化，可处理大量数据。</p>
<p>这些表旨在每秒接收数百万行插入并且存储非常大（100 PB+）的数据量。</p>
<p>数据被快速的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">逐块</a>写入表，并在后台应用规则合并各块。</p>
<p>在 ClickHouse 中，每个数据块都有自己的主键索引。当数据块被合并时，合并部分的主键索引也被合并。</p>
<p>在 ClickHouse 设计的数据规模非常大的情况下，最重要的是要非常高效地使用磁盘和内存。因此，数据块的主键索引不是对每一行都进行索引，而是在每组行数据（称为“粒度”）中有一个索引项（称为“mark”）。</p>
<p>这种稀疏索引是能实现的，因为 ClickHouse 将数据块的行存储在按主键列排序的磁盘上。</p>
<p>稀疏索引不是直接定位单行（如基于 B-Tree 的索引），而是通过它快速（通过对索引项的二分搜索）识别可能与查询匹配的行组。</p>
<p>然后将定位的潜在匹配行（粒度）组并行的流式传输到 ClickHouse 引擎中以找到匹配项。</p>
<p>这种索引设计允许索引很小（它可以而且必须完全满足主内存），同时仍然显着加快查询执行时间：特别是对于数据分析用例中典型的范围查询。</p>
<p>下面详细说明 ClickHouse是如何构建和使用稀疏索引的。稍后在本文中，我们将讨论一些如何选择、删除和排序用于构建索引的表列（主键列）的最佳实践。</p>
<h2 id="具有主键的表"><a href="#具有主键的表" class="headerlink" title="具有主键的表"></a>具有主键的表</h2><p>创建一个具有复合主键的表，其中包含键列 UserID 和 URL：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_UserID_URL
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>UserID<span class="token punctuation">,</span> URL<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>DDL语句详情</p>
<p>为了简化本文后面的探索，并使图表和结果可重现，DDL 声明为</p>
<ul>
<li><p>通过<strong>ORDER BY</strong>子句为表指定组合排序键</p>
</li>
<li><p>通过以下设置显式控制主键索引将具有的索引项：</p>
<ul>
<li>index_granularity：显式设置为其默认值 8192。这意味着对于每组的 8192 行，主键索引将包含一个索引项，例如，如果表包含 16384 行，那么索引将有两个索引项。</li>
<li>index_granularity_bytes：设置为 0 以禁用<code>自适应索引粒度</code>。自适应索引粒度意味着 ClickHouse 自动为一组 n 行数据创建一个索引项<ul>
<li>如果 n 小于 8192，但该 n 行的组合行数据的大小大于或等于 10 MB（index_granularity_bytes 的默认值）或</li>
<li>如果 n 行的组合行数据大小小于 10 MB，但 n 为 8192。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>通过上面 DDL 语句中的主键索引声明，将基于两个指定列创建主键索引。</p>
<p>接下来写入数据：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_UserID_URL <span class="token keyword">SELECT</span>
   intHash32<span class="token punctuation">(</span><span class="token number">c11</span>::UInt64<span class="token punctuation">)</span> <span class="token keyword">AS</span> UserID<span class="token punctuation">,</span>
   <span class="token number">c15</span> <span class="token keyword">AS</span> URL<span class="token punctuation">,</span>
   <span class="token number">c5</span> <span class="token keyword">AS</span> EventTime
<span class="token keyword">FROM</span> url<span class="token punctuation">(</span>'https:<span class="token comment" spellcheck="true">//datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz')</span>
<span class="token keyword">WHERE</span> URL <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">0 rows in set. Elapsed: 149.432 sec. Processed 8.87 million rows, 18.40 GB (59.38 thousand rows/s., 123.16 MB/s.)</code></pre>
<p>然后optimize表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_UserID_URL FINAL<span class="token punctuation">;</span></code></pre>
<p>我们可以使用以下查询来获取有关我们表的元数据：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    part_type<span class="token punctuation">,</span>
    path<span class="token punctuation">,</span>
    formatReadableQuantity<span class="token punctuation">(</span><span class="token keyword">rows</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">rows</span><span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_uncompressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_uncompressed_bytes<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>data_compressed_bytes<span class="token punctuation">)</span> <span class="token keyword">AS</span> data_compressed_bytes<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>primary_key_bytes_in_memory<span class="token punctuation">)</span> <span class="token keyword">AS</span> primary_key_bytes_in_memory<span class="token punctuation">,</span>
    marks<span class="token punctuation">,</span>
    formatReadableSize<span class="token punctuation">(</span>bytes_on_disk<span class="token punctuation">)</span> <span class="token keyword">AS</span> bytes_on_disk
<span class="token keyword">FROM</span> system<span class="token punctuation">.</span>parts
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span><span class="token keyword">table</span> <span class="token operator">=</span> <span class="token string">'hits_UserID_URL'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
FORMAT Vertical<span class="token punctuation">;</span></code></pre>
<p>结果如下：</p>
<pre class=" language-response"><code class="language-response">part_type:                   Wide
path:                        ./store/d9f/d9f36a1a-d2e6-46d4-8fb5-ffe9ad0d5aed/all_1_9_2/
rows:                        8.87 million
data_uncompressed_bytes:     733.28 MiB
data_compressed_bytes:       206.94 MiB
primary_key_bytes_in_memory: 96.93 KiB
marks:                       1083
bytes_on_disk:               207.07 MiB


1 rows in set. Elapsed: 0.003 sec.</code></pre>
<p>ClickHouse 客户端的输出表明：</p>
<ul>
<li>表数据以<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage">宽格式</a>存储在磁盘上的特定目录中，这意味着该目录中的每个表列将有一个数据文件（和一个标记文件）。</li>
<li>该表有 887 万行。</li>
<li>所有行的未压缩数据大小合计为 733.28 MB。</li>
<li>所有行的压缩磁盘数据大小合计为 206.94 MB。</li>
<li>该表有一个包含 1083 项（称为“mark”）的主键索引，索引的大小为 96.93 KB。</li>
<li>表的数据和标记文件以及主键索引文件总共占用了 207.07 MB 磁盘空间。</li>
</ul>
<h2 id="数据按主键列顺序存储在磁盘上"><a href="#数据按主键列顺序存储在磁盘上" class="headerlink" title="数据按主键列顺序存储在磁盘上"></a>数据按主键列顺序存储在磁盘上</h2><p>我们在上面创建的表包含有</p>
<ul>
<li><p>组合<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">主键</a> (UserID, URL)</p>
</li>
<li><p>组合<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#choosing-a-primary-key-that-differs-from-the-sorting-key">排序键</a> (UserID, URL, EventTime)</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>如果我们只指定排序键，那么主键将被隐式定义为排序键。</p>
</li>
<li><p>为了提高内存效率，我们明确的指定了一个主键，它只包含我们查询需要过滤的列。因为基于主键的索引会被完全加载到主存中。</p>
</li>
<li><p>为了使文章的图表中保持一致性，并为了最大限度地提高压缩率，我们定义了一个单独的排序键，其中包括我们表的所有列（如果在一列中相似的数据彼此接近，例如通过排序，那么数据将被更好地压缩）。</p>
</li>
<li><p>如果两者都指定，则主键必须为排序键的前缀。</p>
</li>
</ul>
</blockquote>
<p>插入的行按主键列（以及排序键中的附加 EventTime 列）按字典顺序（升序）存储在磁盘上。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><blockquote>
<p>ClickHouse 允许插入具有相同主键列值的多行。在这种情况下（参见下图中的第 1 行和第 2 行），最终顺序由指定的排序键决定，因此由EventTime列的值决定。</p>
</blockquote>
<p>ClickHouse 是一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#true-column-oriented-dbms">面向列的数据库管理系统</a>。如下图所示</p>
<ul>
<li>对于磁盘来说，表的每个列都有一个数据文件（*.bin），其中该列的所有值都以<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>格式存储。</li>
<li>887 万行按主键列（和附加的排序键列）按字典升序存储在磁盘上，即在这种情况下<ul>
<li>首先由UserID排序，</li>
<li>然后通过URL排序，</li>
<li>最后是EventTime排序：</li>
</ul>
</li>
</ul>
<p><img src="../../images/sparse-primary-indexes-01.png" alt="img">UserID.bin、URL.bin 和 EventTime.bin 是磁盘上的数据文件，其中存储了UserID、URL和EventTime列的值。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>由于主键定义了磁盘上行的字典顺序，因此一张表只能有一个主键。</li>
<li>我们从 0 开始对行进行编号，以便与 ClickHouse 内部行编号结构对齐，该方案也用于记录消息。</li>
</ul>
</blockquote>
<h2 id="数据被分成粒度以进行并行数据处理"><a href="#数据被分成粒度以进行并行数据处理" class="headerlink" title="数据被分成粒度以进行并行数据处理"></a>数据被分成粒度以进行并行数据处理</h2><p>出于数据处理的目的，一个表的列值在逻辑上被划分为粒度组。粒度组是ClickHouse 进行流式数据处理的<strong>最小不可分割</strong>的数据集。这意味着，ClickHouse 不是读取单个行，而是始终读取（以流式和并行方式）整个组（粒度组）的行数据。</p>
<blockquote>
<p>列值并不是实际存储在粒度组内部：粒度组只是用于查询处理的列值的 <em>逻辑</em> 组织。</p>
</blockquote>
<p>下图说明了我们表的 887 万行（列值）是如何被组织成 1083 个粒度组的，这是由于表的 DDL 语句设置了index_granularity（设置为其默认值 8192）。</p>
<p><img src="../../images/sparse-primary-indexes-02.png" alt="img"></p>
<p>第一个（基于磁盘上的物理顺序）8192 行（它们的列值）逻辑上属于粒度 0，然后接下来的 8192 行（它们的列值）属于粒度1，依此类推。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>最后一个粒度组（粒度值1082）“包含”少于 8192 行。</li>
<li>我们将主键列（UserID、URL）中的一些列值标记为橙色。</li>
</ul>
<p>这些橙色标记的列值是每个粒度组中每个主键列的最小值。这里的例外是我们标记最后一个粒度组（上图中的1082粒度组）的最大值。 </p>
<p> 正如我们将在下面看到的，这些橙色标记的列值将是表的主键索引中的索引项。</p>
<ul>
<li>我们从 0 开始对粒度组进行编号，以便与 ClickHouse 内部编号方案保持一致，该方案也用于记录消息。</li>
</ul>
</blockquote>
<h2 id="主键索引每个粒度组有一个索引项"><a href="#主键索引每个粒度组有一个索引项" class="headerlink" title="主键索引每个粒度组有一个索引项"></a>主键索引每个粒度组有一个索引项</h2><p>主键索引是基于上图所示的粒度组创建的。该索引是一个未压缩的扁平化数组文件 (primary.idx)，包含从 0 开始的所谓数字索引标记。</p>
<p>如下图显示，索引文件存储了每个粒度组的最小主键列值（上图中橙色标记的值）。例如</p>
<ul>
<li>第一个索引项（下图中的’mark 0’）存储上图中粒度组0的主键列的最小值，</li>
<li>第二个索引项（下图中的’mark 1’）存储上图中粒度组1的主键列的最小值，依此类推。</li>
</ul>
<p><img src="../../images/sparse-primary-indexes-03a.png" alt="img"></p>
<p>我们的表总共有 1083 个索引项，887 万行数据和 1083 个粒度组：</p>
<p><img src="../../images/sparse-primary-indexes-03b.png" alt="img"></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>最后一个索引项（上图中的’mark 1082’）是存储上图中粒度组1082的主键列的<strong>最大值</strong>。</li>
<li>索引项（索引标记）不是基于我们表中的特定行，而是基于粒度组。例如，对于上图中的索引项’mark 0’，我们的表中没有UserID为240.923且URL为”goal://metry=10000467796a411…”的行。相反，表中有一个粒度组 0，其中在该粒度组中，最小 UserID 值为240.923，最小 URL 值为“goal://metry=10000467796a411…”，这两个值来自不同的行。</li>
<li>主键索引文件被完全加载到主内存中。如果文件大于可用的内存空间，那么ClickHouse 将抛出错误。</li>
</ul>
</blockquote>
<p>主键索引项被称为索引标记，因为每个索引项都标记特定数据范围的最小值。对于示例表：</p>
<ul>
<li><p>UserID索引标记：</p>
<p>主键索引中存储的UserID值按升序排列。<br>上图中的“mark 1”因此代表了在粒度组 1 中的所有行的UserID值，以及在所有后续粒度组中，都保证大于或等于 4.073.710。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#the-primary-index-is-used-for-selecting-granules">正如我们稍后将看到</a>的，当查询在主键的第一列上进行过滤时，这种全局顺序使 ClickHouse 能够在第一个主键列的索引标记上<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">使用二分查找算法</a>。</p>
<ul>
<li><p>URL 索引标记：<br>主键列UserID和URL的基数非常相似，这意味着第一列之后的所有主键列的索引标记通常只代表每个粒度组的数据范围。<br>例如，上图中的URL列的’mark 0’表示粒度组0中所有行的URL值都保证大于等于goal://metry=10000467796a411 …。但是，对于粒度组1中所有行的URL值则不能给出同样的保证，因为UserID列的“mark 1”与“mark 0”具有不同的 UserID 值。</p>
<p>稍后我们将更详细地讨论这对查询执行性能的影响。</p>
</li>
</ul>
<h2 id="主键索引用于选择粒度组"><a href="#主键索引用于选择粒度组" class="headerlink" title="主键索引用于选择粒度组"></a>主键索引用于选择粒度组</h2><p>我们现在可以在主键索引的支持下执行以下查询。</p>
<p>下面计算UserID 为 749927693 点击次数前十的 url。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.005 sec.
Processed 8.19 thousand rows,
740.18 KB (1.53 million rows/s., 138.59 MB/s.)</code></pre>
<p>ClickHouse 客户端的输出此时说明，不是进行全表扫描，而是只有 8190行数据流式传输到 ClickHouse。</p>
<p>如果启用了<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">跟踪日志</a>，ClickHouse 服务器日志文件将显示 ClickHouse 正在对 1083 个 UserID 索引标记执行<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分查找</a>，从而找到可能包含 UserID 列值为749927693的行的粒度组。这需要平均时间复杂度为O(log2 n)的 19 个步骤：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in [749927693, 749927693])
...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)
...Executor): Found (LEFT) boundary mark: 176
...Executor): Found (RIGHT) boundary mark: 177
...Executor): Found continuous range in 19 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              1/1083 marks by primary key, 1 marks to read from 1 ranges
...Reading ...approx. 8192 rows starting from 1441792</code></pre>
<p>我们从上面的跟踪日志中可以看出，1083 个现有标记中的一个标记满足查询。</p>
<blockquote>
<p>跟踪日志细节</p>
<p>标记 176 被识别（包含“找到的左边界标记”，排除“找到的右边界标记”），因此来自粒度 176 的所有 8192 行（从第 1.441.792 行开始 - 我们将在稍后看到）流式传输到 ClickHouse 中，以查找 UserID 列值为749927693的实际行。</p>
</blockquote>
<p>我们还可以通过在示例查询中使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/explain/">EXPLAIN 子句</a>来重现这一点：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> indexes <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">┌─explain───────────────────────────────────────────────────────────────────────────────┐
│ Expression (Projection)                                                               │
│   Limit (preliminary LIMIT (without OFFSET))                                          │
│     Sorting (Sorting for ORDER BY)                                                    │
│       Expression (Before ORDER BY)                                                    │
│         Aggregating                                                                   │
│           Expression (Before GROUP BY)                                                │
│             Filter (WHERE)                                                            │
│               SettingQuotaAndLimits (Set limits and quota after reading from storage) │
│                 ReadFromMergeTree                                                     │
│                 Indexes:                                                              │
│                   PrimaryKey                                                          │
│                     Keys:                                                             │
│                       UserID                                                          │
│                     Condition: (UserID in [749927693, 749927693])                     │
│                     Parts: 1/1                                                        │
│                     Granules: 1/1083                                                  │
└───────────────────────────────────────────────────────────────────────────────────────┘

16 rows in set. Elapsed: 0.003 sec.</code></pre>
<p>客户端输出表明1083 个粒度组中的一个被选为可能包含 UserID 列值为 749927693 的行。</p>
<blockquote>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h5><p>当对作为组合主键的一部分且是第一个主键列进行查询过滤时，ClickHouse 将在主键列的索引标记上运行二分查找算法。</p>
</blockquote>
<p>如上所述，ClickHouse 正在使用其稀疏主键索引来快速（通过二分查找）选择可能包含与查询匹配的行的粒度组。</p>
<p>这是 ClickHouse 执行查询的<strong>第一阶段（粒度组选择）</strong>。</p>
<p>在<strong>第二阶段（数据读取）</strong>，ClickHouse 定位到选定的粒度组，以便将它们的所有行数据流式传输到 ClickHouse 引擎，从而找到实际匹配查询的行。</p>
<p>我们接下来将再更详细地讨论第二阶段。</p>
<h2 id="标记文件用于定位粒度组"><a href="#标记文件用于定位粒度组" class="headerlink" title="标记文件用于定位粒度组"></a>标记文件用于定位粒度组</h2><p>下图展示了我们表的主键索引文件的一部分。</p>
<p><img src="../../images/sparse-primary-indexes-04.png" alt="img"></p>
<p>如上所述，通过对索引的 1083 个UserID标记进行二分搜索，识别出标记 176。因此，其对应的粒度组176 可能包含 UserID 列值为 749.927.693 的行。</p>
<blockquote>
<p>粒度组选择细节</p>
<p>上图显示，标记 176 是第一个匹配的索引项，其中粒度组 176 的最小 UserID 值小于 749.927.693，并且下一个标记（标记 177）的粒度组177 的最小 UserID 值大于此值。因此，只有176 标记对应的粒度组可能包含 UserID 列值为 749.927.693 的行。</p>
</blockquote>
<p>为了确定（或不确定）粒度组 176 中的某些行包含 UserID 列值为749.927.693  ，属于该粒度组的所有 8192 行都需要流式传输到 ClickHouse。</p>
<p>为此，ClickHouse 需要知道粒度组 176 的物理位置。</p>
<p>在 ClickHouse 中，我们表的所有粒度组的物理位置都存储在标记文件中。与数据文件类似，每个列都有一个标记文件。</p>
<p>下图展示了三个标记文件 UserID.mrk、URL.mrk 和 EventTime.mrk，它们存储了表的 UserID、URL 和 EventTime 列的粒度组的物理位置。</p>
<p><img src="../../images/sparse-primary-indexes-05.png" alt="img"></p>
<p>我们已经讨论了主键索引为什么是一个扁平的未压缩数组文件 (primary.idx)，其中包含从 0 开始编号的索引标记。</p>
<p>同样，标记文件也是一个扁平未压缩的数组文件 (*.mrk)，其中包含从 0 开始编号的标记。</p>
<p>一旦 ClickHouse 识别并选择了可能包含查询匹配行的粒度组的索引标记，就可以在标记文件中执行查找数组位置，以获得粒度组的实际物理位置。</p>
<p>特定列的每个标记文件项都以偏移量的形式存储两个位置：</p>
<ul>
<li>第一个偏移量（上图中的“block_offset”）用于在<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression">压缩</a>列数据文件中定位<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/development/architecture/#block">块</a>，包含所选粒度组的压缩版本。该压缩块可能包含一些压缩粒度组。定位的压缩文件块在读取时被解压到主内存中。</li>
<li>标记文件的第二个偏移量（上图中的“granule_offset”）提供了未压缩块数据中颗粒的位置。</li>
</ul>
<p>然后将被定位的未压缩粒度的所有 8192 行流式传输到 ClickHouse 以进行进一步处理。</p>
<blockquote>
<p><strong>为什么用标记文件</strong></p>
<p>为什么主索引不直接包含索引标记对应的粒度的物理位置？</p>
<p>因为在 ClickHouse 的非常大的数据规模下，十分重要的是磁盘和内存高效使用。</p>
<p>主索引文件需要加载到主内存。</p>
<p>对于我们的示例查询，ClickHouse 使用了主索引并选择了一个可能包含与我们的查询匹配的行的单个粒度。只有对于那个粒度，ClickHouse 才需要物理位置，以便流式传输相应的行以进行进一步处理。</p>
<p>此外，仅 UserID 和 URL 列需要此偏移信息。</p>
<p>查询中未使用的列不需要偏移信息，例如 EventTime。</p>
<p>对于我们的示例查询，Clickhouse 只需要 UserID 数据文件 (UserID.bin) 中粒度 176 的两个物理位置偏移量和 URL 数据文件 (URL.data) 中粒度 176 的两个物理位置偏移量。</p>
<p>标记文件的存在，间接地避免了在主索引中直接存储所有三列的所有 1083 个粒度的物理位置的条目：从而避免在主内存中存在不必要的（可能未使用的）数据。</p>
</blockquote>
<p>下图和下面的文本说明了我们的示例是如何查询 ClickHouse 在 UserID.bin 数据文件中定位粒度 176的。</p>
<p><img src="../../images/sparse-primary-indexes-06.png" alt="img"></p>
<p>我们在本文前面讨论过 ClickHouse选择了主索引标记 176，因此粒度 176 可能包含我们查询的匹配行。</p>
<p>ClickHouse 现在使用从索引中选择的标记编号 (176) 在 UserID.mrk 标记文件中进行数组的位置查找，以获得用于定位颗粒 176 的两个偏移量。</p>
<p>如图所示，第一个偏移量是在 UserID.bin 数据文件中定位压缩文件块，该文件包含粒度 176 的压缩版本。</p>
<p>一旦定位的文件块被解压到主内存中，标记文件的第二个偏移量可用于在未压缩数据中定位粒度176。</p>
<p>ClickHouse 需要从 UserID.bin 数据文件和 URL.bin 数据文件中定位（并从其中流式传输所有值）粒度 176 以执行我们的示例查询（UserID 为749.927. 693的互联网用户的前 10 个点击次数最多的 url )。</p>
<p>上图展示了 ClickHouse 如何定位 UserID.bin 数据文件的粒度。</p>
<p>此外，ClickHouse 对 URL.bin 数据文件的粒度 176 执行相同的操作。将两个各自的粒度对齐，并流式传输到 ClickHouse 引擎中进行进一步处理，即对 UserID 为 749.927.693 的所有行的每个组的 URL 值进行聚合和计数，最后按降序输出最大的 10 个 URL 组。</p>
<h1 id="使用多个主键索引"><a href="#使用多个主键索引" class="headerlink" title="使用多个主键索引"></a>使用多个主键索引</h1><h2 id="辅助键是否有效"><a href="#辅助键是否有效" class="headerlink" title="辅助键是否有效"></a>辅助键是否有效</h2><p>当查询对复合主键的一部分并且是第一个键列进行过滤时，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">ClickHouse 将在键列的索引标记上执行二分搜索算法</a>。</p>
<p>但是，当查询对复合主键的一部分但不是第一个键列进行过滤时会发生什么？</p>
<blockquote>
<p><strong>注意</strong></p>
<p>我们讨论一个查询保证不是在第一个键列上过滤，而是在辅助键列上过滤的场景。</p>
<p>当查询同时对第一个键列和第一个键列之后的任何键列进行过滤时，ClickHouse 将对第一个键列的索引标记执行二分搜索。</p>
</blockquote>
<p>我们使用一个查询来计算最常点击 URL”http ://public_search”的前 10 个用户：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.086 sec.
Processed 8.81 million rows,
799.69 MB (102.11 million rows/s., 9.27 GB/s.)</code></pre>
<p>客户端的输出表明 ClickHouse 几乎执行了全表扫描，尽管<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">URL 列作为复合主键的一部分</a>！ClickHouse 从表的 887 万行中读取了 881 万行。</p>
<p>如果启用了<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger">trace_logging</a>，则 ClickHouse 服务器日志文件显示 了ClickHouse 对 1083 个 URL 索引标记使用了<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索</a>，以识别可能包含 URL 列值为“http: //public_search”的行的那些粒度：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 1 in ['http://public_search',
                                           'http://public_search'])
...Executor): Used generic exclusion search over index for part all_1_9_2
              with 1537 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              1076/1083 marks by primary key, 1076 marks to read from 5 ranges
...Executor): Reading approx. 8814592 rows with 10 streams</code></pre>
<p>我们可以在上面的示例跟踪日志中看到，1083 个粒度中的 1076 个（通过标记）被选择为可能包含具有匹配 URL 值的行。</p>
<p>这导致 881 万行被流式传输到 ClickHouse 引擎（并行使用 10 个流），以识别实际包含 URL 值“http: //public_search”的行。</p>
<p>然而，<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-fast">正如我们稍后将看到</a>的那样，在选定的 1076 个粒度中只有 39 个粒度实际上包含匹配的行。</p>
<p>虽然基于复合主键 (UserID, URL) 的主索引对于加快具有特定 UserID 值的行的查询过滤非常有用，但该索引在加快过滤具有特定 URL 值的行的查询方面没有提供重要帮助。</p>
<p>原因是 URL 列不是第一个键列，因此 ClickHouse 在 URL 列的索引标记上使用通用排除搜索算法（而不是二分搜索），并且<strong>该算法的效率取决于</strong>URL 列和它的前置键列 UserID的 <strong>基数差异</strong>。</p>
<p>为了说明这一点，我们给出了一些关于通用排除搜索是如何执行的细节。</p>
<h2 id="通用排除搜索算法"><a href="#通用排除搜索算法" class="headerlink" title="通用排除搜索算法"></a>通用排除搜索算法</h2><p>下面说明了<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L14444">ClickHouse 通用排除搜索算法</a>在前置键列具有低（er）或高（er）基数的情况下，辅助键筛选粒度的工作原理。</p>
<p>作为这两种情况的示例，我们将假设：</p>
<ul>
<li>查询 URL 值 = “W3” 的行。</li>
<li>我们的 hits 表的抽象版本，其中包含 UserID 和 URL 的简化值。</li>
<li>索引的相同复合主键 (UserID, URL)。这意味着行首先按 UserID 值排序。然后按 URL 对具有相同 UserID 值的行进行排序。</li>
<li>粒度大小为 2，即每个粒度包含两行。</li>
</ul>
<p>我们在下图中用橙色标记了每个颗粒的最小键列值。</p>
<p><strong>前置键列的基数较低</strong></p>
<p>假设 UserID 具有低基数。在这种情况下，相同的 UserID 值很可能分布在多个表行和粒度上。对于具有相同 UserID 的索引标记，索引标记的 URL 值按升序排序（因为表行首先按 UserID 排序，然后按 URL 排序）。这能进行有效过滤，如下所示：</p>
<p><img src="../../images/sparse-primary-indexes-07.png" alt="img"></p>
<p>上图中我们的抽象样本数据的粒度选择过程有三种不同的场景：</p>
<ol>
<li>由于标记索引0、1和2具有相同的UserID值，因此可以排除（最小）<strong>URL值小于W3并且直接后续索引标记的URL值也小于W3的索引标记0。</strong>请注意，此排除的前提是，确保了粒度 0 和下一个粒度1 完全由 U1的 UserID 值组成，因此 ClickHouse 可以推断粒度 0 中的最大 URL 值也小于 W3， 并排除该颗粒。</li>
<li>选择其<strong>URL 值小于（或等于）W3 并且其直接后续索引标记的 URL 值大于（或等于）W3</strong>的索引标记 1，因为这意味着粒度1 可能包含具有 URL值为W3 的行。</li>
<li><strong>可以排除URL 值大于 W3</strong>的索引标记 2 和 3 ，因为主键索引的索引标记存储每个粒度的最小键列值，因此粒度 2 和 3 不可能包含 URL 值为 W3的行。</li>
</ol>
<p><strong>前置键列的基数的较高</strong></p>
<p>当 UserID 具有高基数时，相同的 UserID 值不太可能分布在多个表行和粒度上。这意味着索引标记的 URL 值不是单调递增的：</p>
<p><img src="../../images/sparse-primary-indexes-08.png" alt="img"></p>
<p>正如我们在上图中看到的，所有显示的 URL 值小于 W3 的标记都被选中，用于将其关联的粒度行都流式传输到 ClickHouse 引擎。</p>
<p>这是因为虽然图中的所有索引标记都属于上述场景 1，但它们不满足上述排除的前提条件，<em>即两个直接随后的索引标记都具有与当前标记相同的 UserID 值</em>，因此不能被排除.</p>
<p>例如，考虑索引标记 0 ，其<strong>URL 值小于 W3 并且直接后续索引标记的 URL 值也存在小于 W3</strong>。这<em>不能</em>排除，因为两个紧随其后的索引标记 1 和 2<em>没有</em>与当前标记 0 相同的 UserID 值。</p>
<p>请注意，要求两个后续索引标记具有相同的 UserID 值。这确保了当前和下一个标记的粒度完全由 U1的 UserID 值组成。如果只有下一个标记具有相同的 UserID，则下一个标记的 URL 值可能源自具有不同 UserID 的表行 - 当您查看上图时确实是这种情况，即 W2 源自 U2，而不是UserID 为U1的行。</p>
<p>这最终会阻止 ClickHouse 对粒度 0 中的最大 URL 值做出推断。相反，它必须假设粒度 0 可能包含 URL 值为 W3 的行，并被迫选择标记 0。</p>
<p>同理，标记 1、2 和 3 也是如此。</p>
<blockquote>
<p><strong>结论</strong></p>
<p>当查询对作为复合键的一部分但不是第一个键的列进行过滤，并且前置键列具有较低基数时，ClickHouse 使用<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1444">通用排除搜索算法而不是</a><a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索算法</a>。</p>
</blockquote>
<p>在我们的示例数据集中，两个键列（UserID、URL）具有相似的高基数，并且如上所述，当 URL 列的前一个键列具有较高或相似的基数时，通用排除搜索算法并不是十分有效.</p>
<h2 id="注意跳数索引"><a href="#注意跳数索引" class="headerlink" title="注意跳数索引"></a>注意跳数索引</h2><p>由于 UserID 和 URL 值具有同样高的基数，在<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">使用复合主键 (UserID, URL)</a>的表上的URL列上创建<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/skipping-indexes">二级跳数索引</a>，并不会<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>有太大的帮助。</p>
<p>例如，以下两个语句在我们表的 URL 列上创建并填充了一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries">minmax跳数索引：</a></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> url_skipping_index URL <span class="token keyword">TYPE</span> minmax GRANULARITY <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL MATERIALIZE <span class="token keyword">INDEX</span> url_skipping_index<span class="token punctuation">;</span></code></pre>
<p>ClickHouse 现在创建了一个附加索引，用于存储 - 每组 4 个连续<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">粒度</a>（注意上面ALTER TABLE语句中的GRANULARITY 4子句） - 的最小和最大 URL 值：</p>
<p><img src="../../images/sparse-primary-indexes-13a.png" alt="img"></p>
<p>第一个索引项（上图中的“mark 0”）存储<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-organized-into-granules-for-parallel-data-processing">表的前 4 个粒度的行</a>的最小和最大 URL 值。</p>
<p>第二个索引项（’mark 1’）存储表的后续 4 个粒度的行的最小和最大 URL 值，依此类推。</p>
<p>（ClickHouse 还为跳数索引创建了一个特殊的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>，用于<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">定位</a>与索引标记关联的粒度组。）</p>
<p>由于 UserID 和 URL 的基数同样高，所以当我们对 URL执行<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">查询过滤</a>时，这个二级跳数索引无法帮助排除被选中的粒度。</p>
<p>查询正在查找的特定 URL 值（如 “http: //public_search”）很可能介于索引为每组粒度存储的最小值和最大值之间，导致 ClickHouse 被迫选择粒度组（因为它们可能包含与查询匹配的行）。</p>
<h2 id="需要使用多个主键索引"><a href="#需要使用多个主键索引" class="headerlink" title="需要使用多个主键索引"></a>需要使用多个主键索引</h2><p>因此，如果我们想要显着加快过滤具有特定 URL 的行的示例查询，那么我们需要使用针对该查询优化的主键索引。</p>
<p>此外，如果我们希望保持过滤具有特定 UserID 的行的示例查询的良好性能，那么我们需要使用多个主键索引。</p>
<p>以下是实现这一目标的方法。</p>
<h2 id="用于创建附加主键索引的选项"><a href="#用于创建附加主键索引的选项" class="headerlink" title="用于创建附加主键索引的选项"></a>用于创建附加主键索引的选项</h2><p>如果我们想显着加快我们的两个示例查询 - 一个过滤具有特定 UserID 的行和一个过滤具有特定 URL 的行 - 那么我们需要通过使用这三个选项之一来使用多个主索引：</p>
<ul>
<li>使用不同的主键创建<strong>第二个表。</strong></li>
<li>在我们现有的表上创建一个<strong>物化视图。</strong></li>
<li>向我们现有的表添加<strong>投影。</strong></li>
</ul>
<p>所有的三个选项都会有效地将我们的样本数据复制到一个附加表中，以便重新组织表的主键索引和行排序顺序。</p>
<p>但是，这三个选项的不同之处在于附加表对于用户查询和插入语句处理的方便程度。</p>
<p>当创建了具有不同主键的<strong>第二个表</strong>后，必须将查询显式发送到最适合查询的表中，并且必须将新数据显式插入两个表中以保持表同步：</p>
<p><img src="../../images/sparse-primary-indexes-09a.png" alt="img"></p>
<p>使用<strong>物化视图</strong>会隐式创建附加表，并且两个表之间的数据会自动保持同步：</p>
<p><img src="../../images/sparse-primary-indexes-09b.png" alt="img"></p>
<p><strong>投影</strong>是最方便的选项，因为除了自动保持隐式创建（和隐藏）附加表与同步数据更改之外，ClickHouse 将自动选择最有效的表版本进行查询：</p>
<p><img src="../../images/sparse-primary-indexes-09c.png" alt="img"></p>
<p>在下文中，我们将通过实例来更详细地讨论创建和使用多个主索引的这三个选项。</p>
<h2 id="选项-1：辅助表"><a href="#选项-1：辅助表" class="headerlink" title="选项 1：辅助表"></a>选项 1：辅助表</h2><p>创建一个新的附加表，在主键中切换了键列的顺序（与原始表相比）：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_URL_UserID
<span class="token punctuation">(</span>
    <span class="token punctuation">`</span>UserID<span class="token punctuation">`</span> UInt32<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>URL<span class="token punctuation">`</span> String<span class="token punctuation">,</span>
    <span class="token punctuation">`</span>EventTime<span class="token punctuation">`</span> <span class="token keyword">DateTime</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
SETTINGS index_granularity <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> index_granularity_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<p>将<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>中的所有的 887 万行数据插入到附加表中：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hits_URL_UserID
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 2.898 sec. Processed 8.87 million rows, 838.84 MB (3.06 million rows/s., 289.46 MB/s.)</code></pre>
<p>最后优化表：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> hits_URL_UserID FINAL<span class="token punctuation">;</span></code></pre>
<p>因为我们切换了主键中列的顺序，插入的行现在以不同的字典顺序存储在磁盘上（与我们的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>相比），因此该表的 1083 个粒度包含与之前不同的值：</p>
<p><img src="../../images/sparse-primary-indexes-10.png" alt="img"></p>
<p>这是生成的主键：</p>
<p><img src="../../images/sparse-primary-indexes-11.png" alt="img"></p>
<p>现在可以使用它来显着加快我们对 URL 列的示例查询过滤，以计算最常点击的 URL”http: //public_search”的前 10 个用户：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_URL_UserID
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.017 sec.
Processed 319.49 thousand rows,
11.38 MB (18.41 million rows/s., 655.75 MB/s.)</code></pre>
<p>现在， ClickHouse<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#filtering-on-key-columns-after-the-first">没有进行全表扫描</a>，而是更有效地执行了该查询。</p>
<p>当使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>的主索引时，其中 UserID 是第一个，URL 是第二个键列，ClickHouse 对索引标记使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-algorithm">通用排除搜索</a>来执行该查询。并且由于 UserID 和URL具有同样高的基数，使得该查询并不高效。</p>
<p>将 URL 作为主索引中的第一列，ClickHouse 现在对索引标记运行<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452">二分搜索</a>。ClickHouse 服务器日志文件中的相应跟踪日志也验证了这一点：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)
...Executor): Found (LEFT) boundary mark: 644
...Executor): Found (RIGHT) boundary mark: 683
...Executor): Found continuous range in 19 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              39/1083 marks by primary key, 39 marks to read from 1 ranges
...Executor): Reading approx. 319488 rows with 2 streams</code></pre>
<p>ClickHouse 仅选择了 39 个索引标记，而不是使用通用排除搜索时的 1076 个。</p>
<p>请注意，附加表经过优化，可加快我们对 URL 的示例查询过滤的执行速度。</p>
<p>与使用<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表</a>时该查询的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url-slow">性能不佳</a>同理，我们对 UserID 的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">示例查询过滤</a>在新的附加表中不会有效地执行，因为 UserID 现在是该表主键索引中的第二个键列，因此 ClickHouse 将使用粒度选择的通用排除搜索，对于相似高基数的 UserID 和 URL列<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不是很有效</a>。以下为详细信息。</p>
<blockquote>
<p>对 UserID 的查询过滤现在性能很差</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> URL<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_URL_UserID
<span class="token keyword">WHERE</span> UserID <span class="token operator">=</span> <span class="token number">749927693</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> URL
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下</p>
<pre class=" language-response"><code class="language-response">┌─URL────────────────────────────┬─Count─┐
│ http://auto.ru/chatay-barana.. │   170 │
│ http://auto.ru/chatay-id=371...│    52 │
│ http://public_search           │    45 │
│ http://kovrik-medvedevushku-...│    36 │
│ http://forumal                 │    33 │
│ http://korablitz.ru/L_1OFFER...│    14 │
│ http://auto.ru/chatay-id=371...│    14 │
│ http://auto.ru/chatay-john-D...│    13 │
│ http://auto.ru/chatay-john-D...│    10 │
│ http://wot/html?page/23600_m...│     9 │
└────────────────────────────────┴───────┘

10 rows in set. Elapsed: 0.024 sec.
Processed 8.02 million rows,
73.04 MB (340.26 million rows/s., 3.10 GB/s.)</code></pre>
<p>服务器日志</p>
<pre class=" language-log"><code class="language-log">...Executor): Key condition: (column 1 in [749927693, 749927693])
...Executor): Used generic exclusion search over index for part all_1_9_2
              with 1453 steps
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              980/1083 marks by primary key, 980 marks to read from 23 ranges
...Executor): Reading approx. 8028160 rows with 10 streams</code></pre>
</blockquote>
<p>我们现在有两张表。分别针对 UserID 的查询过滤和对 URL 的查询过滤进行了优化加速：</p>
<p><img src="../../images/sparse-primary-indexes-12a.png" alt="img"></p>
<h2 id="选项-2：物化视图"><a href="#选项-2：物化视图" class="headerlink" title="选项 2：物化视图"></a>选项 2：物化视图</h2><p>在我们现有的表上创建一个<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">物化视图</a>。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> MATERIALIZED <span class="token keyword">VIEW</span> mv_hits_URL_UserID
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">,</span> EventTime<span class="token punctuation">)</span>
POPULATE
<span class="token keyword">AS</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hits_UserID_URL<span class="token punctuation">;</span></code></pre>
<p>响应如下所示：</p>
<pre class=" language-response"><code class="language-response">Ok.

0 rows in set. Elapsed: 2.935 sec. Processed 8.87 million rows, 838.84 MB (3.02 million rows/s., 285.84 MB/s.)</code></pre>
<blockquote>
<p>注意</p>
<ul>
<li>我们在视图中的主键切换了主键列的顺序（与我们的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">原始表相比）</a></li>
<li>物化视图由<strong>隐式创建的表</strong>支持，该表的行顺序和主键索引基于给定的主键定义</li>
<li>隐式创建的表由SHOW TABLES查询列出，名称以.inner 开头</li>
<li>也可以首先显式地为物化视图创建依赖表，然后视图可以通过TO [db].[table] <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/sql-reference/statements/create/view">子句</a>定位该表。</li>
<li>我们使用POPULATE关键字来立即使用887 万行的源表<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>来填充隐式创建表</li>
<li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐式创建的表中</li>
<li>实际上，隐式创建的表与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主索引：</li>
</ul>
</blockquote>
<p><img src="../../images/sparse-primary-indexes-12b-1.png" alt="img"></p>
<p>ClickHouse 将隐式创建的表的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在 ClickHouse 服务器数据目录的特殊文件夹中：</p>
<p><img src="../../images/sparse-primary-indexes-12b-2.png" alt="img"></p>
<p>支持物化视图的隐式创建的表（以及它的主索引）现在可用于显着加快我们对 URL 列的示例查询过滤的执行速度：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> mv_hits_URL_UserID
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.026 sec.
Processed 335.87 thousand rows,
13.54 MB (12.91 million rows/s., 520.38 MB/s.)</code></pre>
<p>因为实际上支持物化视图的隐式创建的表（以及它的主索引）与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p>
<p>ClickHouse 服务器日志文件中的相应跟踪日志验证了 ClickHouse 正在对索引标记执行二分搜索：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range ...
...
...Executor): Selected 4/4 parts by partition key, 4 parts by primary key,
              41/1083 marks by primary key, 41 marks to read from 4 ranges
...Executor): Reading approx. 335872 rows with 4 streams</code></pre>
<h2 id="选项-3：投影"><a href="#选项-3：投影" class="headerlink" title="选项 3：投影"></a>选项 3：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#option-3-projections">投影</a></h2><p>在我们现有的表上创建一个投影：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL
    <span class="token keyword">ADD</span> PROJECTION prj_url_userid
    <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> <span class="token operator">*</span>
        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>URL<span class="token punctuation">,</span> UserID<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>并实现投影：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> hits_UserID_URL
    MATERIALIZE PROJECTION prj_url_userid<span class="token punctuation">;</span></code></pre>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>投影创建一个<strong>隐藏表</strong>，其行顺序和主键索引基于投影给定的ORDER BY子句</li>
<li>SHOW TABLES查询不能列出隐藏的投影表</li>
<li>我们使用MATERIALIZE关键字，以便立即使用源表<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">hits_UserID_URL</a>中的所有 887 万行填充隐藏表</li>
<li>如果将新行插入到源表 hits_UserID_URL 中，那么这些行也会自动插入到隐藏表中</li>
<li>查询始终（在语法上）以源表 hits_UserID_URL 为目标，但如果隐藏表的行顺序和主索引允许更有效的查询执行，则将使用该隐藏表代替</li>
<li>实际上，隐式创建的隐藏表与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>具有相同的行顺序和主键索引：</li>
</ul>
</blockquote>
<p><img src="../../images/sparse-primary-indexes-12c-1.png" alt="img"></p>
<p>ClickHouse 将隐藏表的<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#data-is-stored-on-disk-ordered-by-primary-key-columns">列数据文件</a>( <em>.bin)、<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#mark-files-are-used-for-locating-granules">标记文件</a>(</em> .mrk2) 和<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-has-one-entry-per-granule">主键索引文件</a>(primary.idx) 存储在源表数据文件、标记文件和主索引文件旁边的特殊文件夹中（在下面的截图中标记为橙色）：</p>
<p><img src="../../images/sparse-primary-indexes-12c-2.png" alt="img"></p>
<p>由投影创建的隐藏表（以及它的主键索引）现在可以（隐式地）用于显着加快我们在 URL 列上执行示例查询过滤的速度。请注意，查询在语法上以投影的源表为目标。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UserID<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>UserID<span class="token punctuation">)</span> <span class="token keyword">AS</span> Count
<span class="token keyword">FROM</span> hits_UserID_URL
<span class="token keyword">WHERE</span> URL <span class="token operator">=</span> 'http:<span class="token comment" spellcheck="true">//public_search'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> UserID
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>响应如下：</p>
<pre class=" language-response"><code class="language-response">┌─────UserID─┬─Count─┐
│ 2459550954 │  3741 │
│ 1084649151 │  2484 │
│  723361875 │   729 │
│ 3087145896 │   695 │
│ 2754931092 │   672 │
│ 1509037307 │   582 │
│ 3085460200 │   573 │
│ 2454360090 │   556 │
│ 3884990840 │   539 │
│  765730816 │   536 │
└────────────┴───────┘

10 rows in set. Elapsed: 0.029 sec.
Processed 319.49 thousand rows, 1
1.38 MB (11.05 million rows/s., 393.58 MB/s.)</code></pre>
<p>由于投影创建的隐藏表（以及它的主索引）实际上与<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes-via-secondary-tables">我们显式创建的辅助表</a>相同，所以查询的执行方式与显式创建的表相同。</p>
<p>ClickHouse 服务器日志文件中的相应跟踪日志证实了ClickHouse 正在对索引标记执行二分搜索：</p>
<pre class=" language-response"><code class="language-response">...Executor): Key condition: (column 0 in ['http://public_search',
                                           'http://public_search'])
...Executor): Running binary search on index range for part prj_url_userid (1083 marks)
...Executor): ...
...Executor): Choose complete Normal projection prj_url_userid
...Executor): projection required columns: URL, UserID
...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,
              39/1083 marks by primary key, 39 marks to read from 1 ranges
...Executor): Reading approx. 319488 rows with 2 streams</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#a-table-with-a-primary-key">具有复合主键 (UserID, URL)的表</a>的主键索引对于加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">UserID 的查询过滤</a>非常有用。但是，尽管 URL 列是复合主键的一部分，但该索引并没有为加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url"> URL 的查询过滤</a>提供重要帮助。</p>
<p>反之亦然：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#secondary-table">具有复合主键 (URL, UserID) 的表</a>的主键索引能加快<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#query-on-url">对 URL 的查询过滤</a>，但<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design/#the-primary-index-is-used-for-selecting-granules">对 UserID的查询过滤</a>没有提供太多帮助。</p>
<p>由于主键列 UserID 和 URL 具有相似的高基数，对第二个键列进行过滤的查询<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-slow">不会从索引中的第二个键列中获得太多帮助</a>。</p>
<p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#multiple-primary-indexes">因此，从主索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主索引</a>是有意义的。</p>
<p>但是，如果复合主键中的键列在基数上有很大差异，则<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple/#generic-exclusion-search-fast">查询</a>按基数升序排列主键列是有益的。</p>
<p>键列之间的基数差异越大，这些列在键中的顺序就越重要。我们将在下一节中证明这一点。</p>
<p>因此，从主键索引中删除第二个键列（从而减少索引的内存消耗）并改用多个主键索引是有意义的。</p>
<p>但是，如果复合主键中的键列在基数上有很大差异，则按基数升序排列的主键列对查询是有帮助的。</p>
<p>键列之间的基数差异越大，这些列在键中的顺序就越重要。 我们将在下一节中说明这一点。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Hairui Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://onehr7.github.io/2022/11/02/ClickHouse优化（译） -- 主键索引/">https://onehr7.github.io/2022/11/02/ClickHouse优化（译） -- 主键索引/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/01/10/Kafka%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"><span>Kafka三节点集群搭建</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/01/14/aJn4RNHLOvf3dDj.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Hairui Wang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>